<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Legendary Moodboard (v4.3 - Maps Edition)</title>
  <style>
    /* v4.3 — EXIF + metadata toggle + YouTube import + save/load + Google Maps + Apple-style background */
    :root{
      --bg:#0f1220; --panel:#161a2b; --text:#e8ecff; --muted:#aab2d5;
      --chip:rgba(255,255,255,.06); --radius:18px; --shadow:0 10px 30px rgba(0,0,0,.45);
      --accent:#8b5cf6; --danger:#ef4444; --group:#3b82f6;
      --handle-bg: rgba(255,255,255,.12); --handle-border: rgba(255,255,255,.55);
      --handle-bg-strong: rgba(255,255,255,.2);
      --node-border: rgba(255,255,255,.18);
      
      /* Apple-style background variables */
      --bg-hue: 220;          /* 200–260 = blue/purple Apple vibe */
      --bg-sat: 28%;          /* overall saturation */
      --bg-light: 12%;        /* base lightness (darker for dark theme) */
      --tile: 4098px;          /* 256/512/1024 */
      --grid-gap: 24px;       /* spacing of the micro dot grid */
      --grain-strength: 0.15; /* 0–0.15 suggested */
      --glow-opacity: 0.55;   /* intensity of aurora layer */
    }
    :root.light{
      --bg:#f7f8fc; --panel:#ffffff; --text:#0e132f; --muted:#5b627e;
      --chip:rgba(0,0,0,.06); --shadow:0 10px 25px rgba(0,0,0,.12);
      --handle-bg: rgba(0,0,0,.12); --handle-border: rgba(0,0,0,.55);
      --handle-bg-strong: rgba(0,0,0,.2);
      --node-border: rgba(0,0,0,.15);
      
      /* Light theme background adjustments */
      --bg-light: 98%;        /* lighter for light theme */
    }
    *{box-sizing:border-box}
    html,body,#root{height:100%}
    body{
      margin:0;color:var(--text);font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;overflow:hidden;
      
      /* Apple-style seamless background */
      background-image:
        /* 1) Micro dot grid (ultra‑subtle) */
        radial-gradient(rgba(255,255,255,.03) 1px, transparent 1.5px),
        /* 2) Fine diagonal fiber */
        repeating-linear-gradient(135deg, rgba(255,255,255,.02) 0 2px, transparent 2px 4px),
        /* 3) Aurora / glow tile (SVG with seamless turbulence) - dark theme */
        url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512'%3E%3Cdefs%3E%3ClinearGradient id='wash' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='hsl(220, 30%25, 15%25)'/%3E%3Cstop offset='100%25' stop-color='hsl(220, 30%25, 8%25)'/%3E%3C/linearGradient%3E%3Cfilter id='aurora' x='-20%25' y='-20%25' width='140%25' height='140%25'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.006' numOctaves='2' seed='8' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0.8 0 0.2 0 0  0 0.8 0.2 0 0  0.2 0 1.2 0 0  0 0 0 .3 0'/%3E%3CfeComponentTransfer%3E%3CfeFuncR type='gamma' amplitude='1.15' exponent='1.2'/%3E%3CfeFuncG type='gamma' amplitude='1.10' exponent='1.1'/%3E%3CfeFuncB type='gamma' amplitude='1.25' exponent='1.3'/%3E%3C/feComponentTransfer%3E%3CfeGaussianBlur stdDeviation='22'/%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23wash)'/%3E%3Crect width='100%25' height='100%25' filter='url(%23aurora)' opacity='0.4'/%3E%3C/svg%3E"),
        /* 4) Soft base wash (CSS gradient) */
        linear-gradient(
          180deg,
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 2%)),
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 4%))
        );

      background-size:
        var(--grid-gap) var(--grid-gap),            /* dot grid size */
        var(--tile) var(--tile),                    /* diagonal fiber repeats on tile */
        var(--tile) var(--tile),                    /* aurora SVG tile */
        cover;                                      /* base wash fills */

      background-position: 0 0, 0 0, 0 0, 0 0;
      background-repeat: repeat, repeat, repeat, no-repeat;
      background-attachment: fixed;
      
      /* Extra polish for Apple‑ish depth */
      -webkit-font-smoothing: antialiased;
      backface-visibility: hidden;
    }
    
    /* Light theme background override */
    :root.light body{
      background-image:
        /* 1) Micro dot grid (ultra‑subtle) */
        radial-gradient(rgba(0,0,0,.04) 1px, transparent 1.5px),
        /* 2) Fine diagonal fiber */
        repeating-linear-gradient(135deg, rgba(0,0,0,.03) 0 2px, transparent 2px 4px),
        /* 3) Aurora / glow tile (SVG with seamless turbulence) - light theme */
        url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512'%3E%3Cdefs%3E%3ClinearGradient id='wash' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='hsl(220, 30%25, 99%25)'/%3E%3Cstop offset='100%25' stop-color='hsl(220, 30%25, 95%25)'/%3E%3C/linearGradient%3E%3Cfilter id='aurora' x='-20%25' y='-20%25' width='140%25' height='140%25'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.006' numOctaves='2' seed='8' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 .75 0'/%3E%3CfeComponentTransfer%3E%3CfeFuncR type='gamma' amplitude='1.15' exponent='1.2'/%3E%3CfeFuncG type='gamma' amplitude='1.10' exponent='1.1'/%3E%3CfeFuncB type='gamma' amplitude='1.25' exponent='1.3'/%3E%3C/feComponentTransfer%3E%3CfeGaussianBlur stdDeviation='22'/%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23wash)'/%3E%3Crect width='100%25' height='100%25' filter='url(%23aurora)' opacity='0.66'/%3E%3C/svg%3E"),
        /* 4) Soft base wash (CSS gradient) */
        linear-gradient(
          180deg,
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 0%)),
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 3%))
        );
    }
    .topbar{
      position:fixed; inset:0 0 auto 0; height:64px; display:flex; align-items:center; justify-content:space-between;
      padding:0 16px; background:linear-gradient(180deg, rgba(0,0,0,.3), rgba(0,0,0,0)); z-index:1000; pointer-events:none;
    }
    .topbar .actions button, .topbar select{pointer-events:auto}
    .brand{display:flex; gap:12px; align-items:center}
    .logo{width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg,#74ebd5,#ACB6E5)}
    .title{font-weight:700}
    .subtitle{font-size:12px; color:var(--muted)}
    .actions{display:flex; gap:8px}
    button{
      background:var(--panel); color:var(--text); border:1px solid rgba(255,255,255,.08);
      border-radius:10px; padding:8px 12px; box-shadow:var(--shadow); cursor:pointer;
    }
    button:hover{filter:brightness(1.1)}
    button:active{transform:translateY(1px)}
    button.danger{background:rgba(239,68,68,.15); border-color:rgba(239,68,68,.35)}
    select{background:var(--panel); color:var(--text); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px 12px}

    /* URL Import Panel */
    .url-panel{
      position:fixed; top:80px; left:16px; width:320px; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:16px; box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    .url-panel h3{margin:0 0 12px; font-size:14px; font-weight:600}
    .url-panel input{
      width:100%; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      border-radius:8px; padding:8px 12px; color:var(--text); font-size:14px; margin-bottom:8px;
    }
    .url-panel input:focus{outline:none; border-color:var(--accent)}
    .url-panel .url-buttons{display:flex; gap:8px}
    .url-panel button{padding:6px 12px; font-size:12px}
    .url-panel .url-types{
      font-size:11px; color:var(--muted); margin-bottom:8px; line-height:1.4;
    }

    /* Save/Load Panel */
    .save-panel{
      position:fixed; top:80px; right:16px; width:320px; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:16px; box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    .save-panel h3{margin:0 0 12px; font-size:14px; font-weight:600}
    .save-panel .save-buttons{display:flex; gap:8px; margin-bottom:12px}
    .save-panel .save-list{max-height:150px; overflow-y:auto}
    .save-item{
      display:flex; justify-content:space-between; align-items:center; padding:8px;
      background:rgba(255,255,255,.04); border-radius:6px; margin-bottom:6px; font-size:12px;
    }
    .save-item button{padding:4px 8px; font-size:11px}

    /* Google Maps Modal */
    .map-modal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 400px; background: var(--panel); border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px; padding: 24px; box-shadow: var(--shadow); z-index: 2000;
      backdrop-filter: blur(20px);
    }
    .map-modal h3 {
      margin: 0 0 16px; font-size: 18px; font-weight: 600; text-align: center;
    }
    .map-modal .input-group {
      margin-bottom: 16px;
    }
    .map-modal label {
      display: block; margin-bottom: 6px; font-size: 14px; font-weight: 500;
    }
    .map-modal input {
      width: 100%; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px; padding: 10px 12px; color: var(--text); font-size: 14px;
    }
    .map-modal input:focus {
      outline: none; border-color: var(--accent);
    }
    .map-modal .modal-buttons {
      display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;
    }
    .map-modal button {
      padding: 8px 16px; font-size: 14px;
    }
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1999;
      backdrop-filter: blur(4px);
    }

    #viewport{position:absolute; inset:0; overflow:hidden; cursor:grab}
    #viewport.dragging{cursor:grabbing}
    #board{position:absolute; inset:auto; transform-origin:0 0; outline:none}
    .grid{
      /* Removed old simple grid background - now using Apple-style background */
    }

    .node{
      position:absolute; border-radius:20px; background:var(--panel); box-shadow:var(--shadow);
      border:1px solid var(--node-border); overflow:visible; user-select:none; cursor:grab;
    }
    .node:active{cursor:grabbing}
    .node.selected{outline:2px solid var(--accent)}
    .node .content{width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,.02)}
    .node .toolbar{position:absolute; top:6px; right:6px; display:flex; gap:6px; z-index:5}
    .node .toolbar button{padding:4px 8px; font-size:12px}

    /* Node title styling - minimal like groups */
    .node .title{
      position:absolute; top:-14px; left:16px; padding:2px 8px; background:var(--panel); 
      border-radius:999px; border:1px solid rgba(255,255,255,.08); font-size:12px;
      max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      cursor:pointer; transition:all 0.2s ease;
    }
    .node .title:hover{
      background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15);
    }
    .node .title.editing{
      background:rgba(255,255,255,.1); border-color:var(--accent); outline:1px solid var(--accent);
      cursor:text;
    }

    .node.image img{width:100%; height:100%; object-fit:contain; background:#000}
    .node.video video{width:100%; height:100%; background:#000}
    .node.pdf iframe, .node.pdf embed{width:100%; height:100%; background:#fff}
    .node.youtube iframe{width:100%; height:100%; border:none; border-radius:16px}
    .node.map iframe{width:100%; height:100%; border:none; border-radius:16px}
    .node.website iframe{width:100%; height:100%; border:none; border-radius:16px}

    .textbox{
      position:absolute; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); color:var(--text);
      border-radius:12px; padding:12px; min-width:240px; min-height:140px; cursor:grab; z-index: 1600;
      box-shadow:0 6px 20px rgba(0,0,0,.35), 0 0 0 2px rgba(255,255,255,.06);
      white-space:pre-wrap; word-break:break-word; text-align:left;
      transition: all 0.2s ease;
      font-size: 18px;
      line-height: 1.5;
      resize: both; /* Changed from 'none' to 'both' for browser resize handles */
      overflow: auto; /* Changed from 'hidden' to 'auto' to work with resize */
    }
    .textbox:hover{
      border-color: rgba(255,255,255,.18);
      box-shadow:0 8px 24px rgba(0,0,0,.4), 0 0 0 2px rgba(255,255,255,.08);
    }
    .textbox:focus{
      outline:none; 
      cursor: text !important;
      border-color: var(--accent);
      box-shadow:0 8px 24px rgba(0,0,0,.45), 0 0 0 2px var(--accent);
    }
    .textbox.selected{
      border-color: var(--accent);
      box-shadow:0 8px 24px rgba(0,0,0,.45), 0 0 0 2px var(--accent);
    }
    .textbox .tb-resizer{
      position:absolute; width:12px; height:12px; right:-6px; bottom:-6px; 
      background:var(--handle-bg); border:2px solid var(--handle-border); 
      border-radius:50%; cursor:nwse-resize; z-index: 10;
      transition: all 0.2s ease;
      opacity: 0.6;
    }
    .textbox:hover .tb-resizer, .textbox.selected .tb-resizer{
      opacity: 1;
      background:var(--handle-bg-strong);
    }
    .textbox .tb-resizer:hover{
      transform: scale(1.2);
    }

    /* Metadata textbox: vertical orientation (narrow column) */
    .textbox.metadata{
      width:280px;
    }
    .textbox .section-title{
      font-weight:700; font-size:18px; opacity:.9; margin:6px 0 4px;
    }
    .textbox .kv{display:grid; grid-template-columns:92px 1fr; gap:4px 8px; font-size:12px; color:var(--muted)}
    .textbox .kv div:nth-child(odd){opacity:.9}
    .textbox .kv div:nth-child(even){color:var(--text)}

    .group{
      position:absolute; border:2px dashed var(--group); border-radius:24px; background:rgba(59,130,246,.06);
    }
    .group .title{
      position:absolute; top:-14px; left:16px; padding:2px 8px; background:var(--panel); border-radius:999px; border:1px solid rgba(255,255,255,.08); font-size:12px;
      cursor:pointer; transition:all 0.2s ease;
    }
    .group .title:hover{
      background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15);
    }
    .group .title.editing{
      background:rgba(255,255,255,.1); border-color:var(--accent); outline:1px solid var(--accent);
      cursor:text;
    }
    .group.selected{outline:2px solid var(--accent)}
    .group .resizer{position:absolute; width:12px; height:12px; right:-6px; bottom:-6px; background:var(--handle-bg); border:2px solid var(--handle-border); border-radius:50%; cursor:nwse-resize}

    .marquee{position:absolute; border:1px dashed rgba(255,255,255,.6); background:rgba(255,255,255,.1); pointer-events:none}

    .menu{position:absolute; display:none; flex-direction:column; background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:6px; z-index:2000}
    .menu.open{display:flex}
    .menu button{background:transparent; border:none; text-align:left; padding:8px 12px; border-radius:8px}
    .menu button:hover{background:rgba(255,255,255,.06)}
    .menu hr{border:none; border-top:1px solid rgba(255,255,255,.08); margin:6px 0}

    .scale-bar{
      position:fixed; left:12px; bottom:12px; display:flex; align-items:center; gap:10px; z-index:1500;
      background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:999px; backdrop-filter: blur(6px);
    }
    /* Drag and drop overlay */
    .drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(139, 92, 246, 0.1);
      border: 3px dashed var(--accent);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    .drop-overlay.active {
      display: flex;
    }
    .drop-message {
      background: var(--panel);
      padding: 24px 32px;
      border-radius: 16px;
      border: 1px solid var(--accent);
      box-shadow: var(--shadow);
      text-align: center;
      pointer-events: none;
    }
    .drop-message h3 {
      margin: 0 0 8px;
      color: var(--accent);
      font-size: 18px;
      font-weight: 600;
    }
    .drop-message p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <div class="title">Blank Space</div>
        <div class="subtitle">Infinite node-based workflow board powered by GPT5</div>
      </div>
    </div>
    <div class="actions">
      <button id="btnUploadImage">Upload Image</button>
      <button id="btnUploadVideo">Upload Video</button>
      <button id="btnUploadPDF">Upload Document</button>
      <select id="theme">
        <option value="dark" selected>Dark</option>
        <option value="light">Light</option>
      </select>
    </div>
  </header>

  <!-- URL Import Panel -->
  <div class="url-panel">
    <h3>Import from URL</h3>
    <div class="url-types">
      Supports: YouTube videos & Shorts, images (JPG, PNG, GIF), and websites
    </div>
    <input type="text" id="urlInput" placeholder="Paste URL here..." />
    <div class="url-buttons">
      <button id="btnImportUrl">Import</button>
      <button id="btnClearUrl">Clear</button>
    </div>
  </div>

  <!-- Save/Load Panel -->
  <div class="save-panel">
    <h3>Save & Load</h3>
    <div class="save-buttons">
      <button id="btnSave">Save Board</button>
      <button id="btnExport">Export JSON</button>
      <button id="btnImport">Import JSON</button>
    </div>
    <div class="save-list" id="saveList"></div>
  </div>

  <div id="root">
    <div id="viewport">
      <div id="board" class="board grid" tabindex="0"></div>
    </div>
    <div class="scale-bar">
      <span id="zoomPct">100%</span>
      <div class="ruler"><div class="tick"></div></div>
    </div>
  </div>

  <!-- Hidden inputs for uploads -->
  <input id="fileImage" type="file" accept="image/*" multiple style="display:none"/>
  <input id="fileVideo" type="file" accept="video/*" multiple style="display:none"/>
  <input id="filePDF" type="file" accept="application/pdf" multiple style="display:none"/>
  <input id="fileImport" type="file" accept=".json" style="display:none"/>

  <!-- Google Maps Modal -->
  <div id="mapModal" class="modal-overlay" style="display:none;">
    <div class="map-modal">
      <h3>Add Google Map Route</h3>
      <div class="input-group">
        <label for="mapStart">Start Point:</label>
        <input type="text" id="mapStart" placeholder="Enter starting location..." />
      </div>
      <div class="input-group">
        <label for="mapDestination">Destination:</label>
        <input type="text" id="mapDestination" placeholder="Enter destination..." />
      </div>
      <div class="modal-buttons">
        <button id="mapCancel">Cancel</button>
        <button id="mapCreate" style="background: var(--accent);">Create Map</button>
      </div>
    </div>
  </div>

  <!-- Context menus -->
  <menu id="canvasMenu" class="menu">
    <button data-action="upload-image">Upload Image…</button>
    <button data-action="upload-video">Upload Video…</button>
    <button data-action="upload-pdf">Upload Document…</button>
    <hr/>
    <button data-action="add-google-map">Add Google Map</button>
    <hr/>
    <button data-action="create-group">Create Group</button>
    <button data-action="create-textbox">Create Text Box</button>
  </menu>

  <menu id="nodeMenu" class="menu">
    <button data-action="open">Open / Play</button>
    <hr/>
    <button data-action="toggle-metadata">Show metadata</button>
    <hr/>
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>

  <menu id="textboxMenu" class="menu">
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>

  <script>
    console.log('Script starting...');
    
    // v4.3 — Image metadata toggle with EXIF parsing, YouTube import, save/load, and Google Maps
    const state = {
      zoom: 1,
      origin: {x: 0, y: 0},
      nodes: [],
      groups: [],
      textboxes: [],
      selection: new Set(),
      nextId: 1,
      isPanning: false,
      panStart: {x:0,y:0},
      originStart: {x:0,y:0}
    };

    const board = document.getElementById('board');
    const viewport = document.getElementById('viewport');
    const canvasMenu = document.getElementById('canvasMenu');
    const nodeMenu = document.getElementById('nodeMenu');
    const textboxMenu = document.getElementById('textboxMenu');

    console.log('Elements found:', {board, viewport, canvasMenu, nodeMenu, textboxMenu});

    function init(){
      console.log('Initializing...');
      resizeBoard();
      bindGlobal();
      bindUrlPanel();
      bindSavePanel();
      bindMapModal();
      createGroup({x:200, y:200});
      applyTransform();
      loadSavedBoards();
      console.log('Initialization complete');
    }

    function resizeBoard(){
      board.style.width = `50000px`;
      board.style.height = `50000px`;
    }

    function applyTransform(){
      board.style.transform = `translate(${state.origin.x}px, ${state.origin.y}px) scale(${state.zoom})`;
      document.getElementById('zoomPct').textContent = `${Math.round(state.zoom*100)}%`;
    }

    function bindGlobal(){
      console.log('Binding global events...');
      
      const themeSel = document.getElementById('theme');
      themeSel.addEventListener('change', ()=> {
        if(themeSel.value==='light') document.documentElement.classList.add('light');
        else document.documentElement.classList.remove('light');
      });

      // Upload triggers
      document.getElementById('btnUploadImage').addEventListener('click', ()=> {
        console.log('Upload image clicked');
        document.getElementById('fileImage').click();
      });
      document.getElementById('btnUploadVideo').addEventListener('click', ()=> {
        console.log('Upload video clicked');
        document.getElementById('fileVideo').click();
      });
      document.getElementById('btnUploadPDF').addEventListener('click', ()=> {
        console.log('Upload PDF clicked');
        document.getElementById('filePDF').click();
      });
      
      document.getElementById('fileImage').addEventListener('change', (e)=> handleFiles(e.target.files));
      document.getElementById('fileVideo').addEventListener('change', (e)=> handleFiles(e.target.files));
      document.getElementById('filePDF').addEventListener('change',  (e)=> handleFiles(e.target.files));

      // Wheel zoom
      viewport.addEventListener('wheel', (e)=>{
        // Prevent board zoom when scrolling inside text inputs/boxes
        const inTextbox = e.target.closest('.textbox');
        const isEditable = e.target.closest('[contenteditable="true"]');
        const isFormInput = e.target.closest('input, textarea');
        if (inTextbox || isEditable || isFormInput) {
          return; // let the element handle its own scrolling
        }
        e.preventDefault();

        const delta = -e.deltaY;
        const zoomFactor = Math.exp(delta*0.001);
        const prev = state.zoom;
        const next = Math.min(4, Math.max(0.2, prev*zoomFactor));
        if(next===prev) return;
        const rect = viewport.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const ox = (cx - state.origin.x) / prev;
        const oy = (cy - state.origin.y) / prev;
        state.origin.x = cx - ox*next;
        state.origin.y = cy - oy*next;
        state.zoom = next;
        applyTransform();
      }, {passive:false});

      // Left-drag on empty canvas pans OR deselects
      viewport.addEventListener('mousedown', (e)=>{
        if(e.button === 1) { // Middle mouse button - pan only
          e.preventDefault();
          startPanning(e);
          return;
        }
        
        if(e.button!==0) return; // Only handle left mouse button for selection/pan
        if (e.target.closest('.textbox')) return;
        if(canvasMenu.classList.contains('open') || nodeMenu.classList.contains('open') || textboxMenu.classList.contains('open')) return;
        
        // Check if clicking on empty space (not on any node, group, or textbox)
        const clickedOnContent = e.target.closest('.node, .group, .textbox');
        
        if(!clickedOnContent) {
          // Clicking on empty space
          if(e.shiftKey) { 
            beginMarquee(e); 
            return; 
          }
          
          // Clear selection on empty space click
          clearSelection();
          
          // Only start panning if we're not just deselecting
          startPanning(e);
        }
      });
      
      // Handle middle mouse button wheel clicks for panning
      viewport.addEventListener('auxclick', (e) => {
        if(e.button === 1) { // Middle mouse button
          e.preventDefault();
          startPanning(e);
        }
      });
    }

    function startPanning(e) {
      state.isPanning = true;
      state.panStart = {x:e.clientX, y:e.clientY};
      state.originStart = {...state.origin};
      viewport.classList.add('dragging');
      
      function move(ev){
        if(!state.isPanning) return;
        state.origin.x = state.originStart.x + (ev.clientX - state.panStart.x);
        state.origin.y = state.originStart.y + (ev.clientY - state.panStart.y);
        applyTransform();
      }
      function up(){
        state.isPanning=false;
        viewport.classList.remove('dragging');
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', up);
      }
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', up);

      // Context menus
      viewport.addEventListener('contextmenu', (e)=>{
        console.log('Context menu triggered');
        e.preventDefault();
        
        const textbox = e.target.closest('.textbox');
        if(textbox && !textbox.classList.contains('metadata')){
          console.log('Opening textbox menu');
          const textboxObj = getTextboxByElement(textbox);
          if(textboxObj) {
            openTextboxMenu(e.clientX, e.clientY, textboxObj);
            return;
          }
        }
        
        const targetNode = e.target.closest('.node');
        if(targetNode){
          console.log('Opening node menu');
          const id = targetNode.dataset.id;
          openNodeMenu(e.clientX, e.clientY, getNodeById(id));
        }else{
          console.log('Opening canvas menu');
          openCanvasMenu(e.clientX, e.clientY);
        }
      });

      // Delete key
      window.addEventListener('keydown', (e)=>{
        const active = document.activeElement;
        if(active && active.classList && active.classList.contains('textbox')) return;
        if(active && active.tagName === 'INPUT') return;
        if(e.key==='Delete' || e.key==='Backspace'){
          const ids = Array.from(state.selection);
          ids.forEach(id=>{
            const n = getNodeById(id); if(n) { n.el.remove(); state.nodes = state.nodes.filter(x=>x!==n); }
            const g = getGroupById(id); if(g) { g.el.remove(); state.groups = state.groups.filter(x=>x!==g); }
            const t = getTextboxById(id); if(t) { t.element.remove(); state.textboxes = state.textboxes.filter(x=>x!==t); }
          });
          clearSelection();
        }
      });

      window.addEventListener('resize', applyTransform);
      
      // Setup drag and drop functionality
      setupDragAndDrop();
    }

    function bindUrlPanel(){
      console.log('Binding URL panel...');
      const urlInput = document.getElementById('urlInput');
      const btnImport = document.getElementById('btnImportUrl');
      const btnClear = document.getElementById('btnClearUrl');

      btnImport.addEventListener('click', ()=>{
        console.log('Import button clicked');
        const url = urlInput.value.trim();
        if(url){
          importFromUrl(url);
          urlInput.value = '';
        } else {
          alert('Please enter a URL');
        }
      });

      btnClear.addEventListener('click', ()=>{
        console.log('Clear button clicked');
        urlInput.value = '';
      });
    }

    function bindSavePanel(){
      console.log('Binding save panel...');
      document.getElementById('btnSave').addEventListener('click', saveBoard);
      document.getElementById('btnExport').addEventListener('click', exportBoard);
      document.getElementById('btnImport').addEventListener('click', ()=> document.getElementById('fileImport').click());
      document.getElementById('fileImport').addEventListener('change', importBoard);
    }

    function bindMapModal(){
      console.log('Binding map modal...');
      const modal = document.getElementById('mapModal');
      const startInput = document.getElementById('mapStart');
      const destInput = document.getElementById('mapDestination');
      const cancelBtn = document.getElementById('mapCancel');
      const createBtn = document.getElementById('mapCreate');

      cancelBtn.addEventListener('click', closeMapModal);
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeMapModal();
      });

      createBtn.addEventListener('click', () => {
        const start = startInput.value.trim();
        const destination = destInput.value.trim();
        
        if (!start || !destination) {
          alert('Please enter both start point and destination');
          return;
        }
        
        createGoogleMapNode(start, destination);
        closeMapModal();
      });

      // Handle Enter key
      [startInput, destInput].forEach(input => {
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            if (input === startInput && !destInput.value.trim()) {
              destInput.focus();
            } else {
              createBtn.click();
            }
          }
          if (e.key === 'Escape') {
            closeMapModal();
          }
        });
      });
    }

    function openMapModal() {
      console.log('Opening map modal...');
      const modal = document.getElementById('mapModal');
      const startInput = document.getElementById('mapStart');
      const destInput = document.getElementById('mapDestination');
      
      // Clear previous values
      startInput.value = '';
      destInput.value = '';
      
      modal.style.display = 'block';
      setTimeout(() => startInput.focus(), 100);
    }

    function closeMapModal() {
      console.log('Closing map modal...');
      document.getElementById('mapModal').style.display = 'none';
    }

    function createGoogleMapNode(start, destination) {
      console.log('Creating Google Map node:', { start, destination });
      
      // Create Google Maps URL that opens in new window/tab
      const encodedStart = encodeURIComponent(start);
      const encodedDest = encodeURIComponent(destination);
      
      // Use a working Google Maps embed URL for directions
      // This constructs a URL that shows directions between two points
      const mapUrl = `https://www.google.com/maps/embed?pb=!1m24!1m8!1m3!1d387190.2799160891!2d-74.25987368715491!3d40.697670063539654!3m2!1i1024!2i768!4f13.1!4m13!3e6!4m5!1s${encodedStart}!3m2!1d0!2d0!4m5!1s${encodedDest}!3m2!1d0!2d0!5e0!3m2!1sen!2sus!4v1634567890123`;
      
      // Alternative: Use a simpler search-based embed that's more reliable
      const searchMapUrl = `https://www.google.com/maps/embed/v1/search?key=AIzaSyB2YCH9BZjHzPP2C7KQCJFd4y2j&q=${encodedStart}+to+${encodedDest}`;
      
      // For maximum compatibility, let's use the search approach with a fallback
      const workingMapUrl = `https://maps.google.com/maps?q=${encodedStart}+to+${encodedDest}&output=embed`;
      
      const rect = viewport.getBoundingClientRect();
      const pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      
      const size = { w: 560, h: 400 };
      const meta = {
        start: start,
        destination: destination,
        mapType: 'directions',
        embedUrl: workingMapUrl,
        fullUrl: `https://www.google.com/maps/dir/${encodedStart}/${encodedDest}`
      };
      
      return createNode('map', workingMapUrl, size, pos, meta);
    }

    function importFromUrl(url){
      console.log('Importing from URL:', url);
      
      const rect = viewport.getBoundingClientRect();
      const pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      
      // Detect URL type and handle accordingly
      const urlType = detectUrlType(url);
      
      switch(urlType) {
        case 'youtube':
        case 'youtube-shorts':
          const videoId = extractYouTubeId(url);
          if(videoId) {
            createYouTubeNode(videoId, pos, urlType === 'youtube-shorts');
          } else {
            alert('Invalid YouTube URL');
          }
          break;
          
        case 'image':
          createImageFromUrl(url, pos);
          break;
          
        case 'website':
          createWebsiteNode(url, pos);
          break;
          
        default:
          alert('Unsupported URL type. Please use YouTube, image URLs (JPG, PNG, GIF), or website URLs.');
      }
    }

    function detectUrlType(url) {
      // YouTube regular videos
      if(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)/i.test(url)) {
        return 'youtube';
      }
      
      // YouTube Shorts
      if(/youtube\.com\/shorts\//i.test(url)) {
        return 'youtube-shorts';
      }
      
      // Image URLs
      if(/\.(jpg|jpeg|png|gif|webp|svg|bmp)(\?.*)?$/i.test(url)) {
        return 'image';
      }
      
      // Website URLs (anything with http/https that's not above)
      if(/^https?:\/\//i.test(url)) {
        return 'website';
      }
      
      return 'unknown';
    }

    function extractYouTubeId(url){
      const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/v\/([^&\n?#]+)/,
        /youtube\.com\/shorts\/([^&\n?#]+)/  // Added support for Shorts
      ];
      for(const pattern of patterns){
        const match = url.match(pattern);
        if(match) return match[1];
      }
      return null;
    }

    function createYouTubeNode(videoId, at, isShorts = false){
      const embedUrl = `https://www.youtube.com/embed/${videoId}`;
      // Shorts are typically vertical, regular videos are horizontal
      const size = isShorts ? {w: 315, h: 560} : {w: 560, h: 315};
      const meta = {
        videoId: videoId,
        platform: 'youtube',
        embedUrl: embedUrl,
        isShorts: isShorts
      };
      return createNode('youtube', embedUrl, size, at, meta);
    }

    function createImageFromUrl(url, at) {
      console.log('Creating image from URL:', url);
      
      // Create a temporary image to get dimensions
      const img = new Image();
      img.crossOrigin = 'anonymous'; // Try to avoid CORS issues
      
      img.onload = function() {
        const naturalW = img.naturalWidth;
        const naturalH = img.naturalHeight;
        const size = calculateOptimalImageSize(naturalW, naturalH);
        
        const meta = {
          originalUrl: url,
          dimensions: {w: naturalW, h: naturalH},
          source: 'url'
        };
        
        createNode('image', url, size, at, meta);
      };
      
      img.onerror = function() {
        alert('Failed to load image from URL. The image may not be accessible or may have CORS restrictions.');
      };
      
      img.src = url;
    }

    function createWebsiteNode(url, at) {
      console.log('Creating website node:', url);
      
      // Ensure URL has protocol
      if (!url.match(/^https?:\/\//i)) {
        url = 'https://' + url;
      }
      
      const size = { w: 800, h: 600 };
      const meta = {
        originalUrl: url,
        website: true,
        domain: extractDomain(url)
      };
      
      return createNode('website', url, size, at, meta);
    }

    function extractDomain(url) {
      try {
        return new URL(url).hostname;
      } catch (e) {
        return 'Unknown';
      }
    }

    // Floating textbox with proper functionality
    function createFloatingTextbox(at){
      console.log('Creating textbox at:', at);
      const id = 't'+(state.nextId++);
      const el = document.createElement('div');
      el.className = 'textbox';
      el.contentEditable = 'true';
      el.spellcheck = false;
      el.dataset.id = id;
      el.style.left = at.x + 'px';
      el.style.top = at.y + 'px';
      el.style.width = '280px';
      el.style.height = '160px';
      
      const textboxObj = {
        id: id,
        element: el
      };
      
      state.textboxes.push(textboxObj);
      
      // Add placeholder
      el.innerHTML = '<span style="color: var(--muted); opacity: 0.7;">Click to start typing...</span>';
      
      let isPlaceholder = true;
      let isEditing = false;
      
      el.addEventListener('focus', ()=>{
        if(isPlaceholder){
          el.innerHTML = '';
          isPlaceholder = false;
        }
        isEditing = true;
        el.style.cursor = 'text';
      });
      
      el.addEventListener('blur', ()=>{
        if(el.textContent.trim() === ''){
          el.innerHTML = '<span style="color: var(--muted); opacity: 0.7;">Click to start typing...</span>';
          isPlaceholder = true;
        }
        isEditing = false;
        el.style.cursor = 'grab';
      });

      // Selection and dragging
      el.addEventListener('mousedown', (e)=>{
        if(e.target.classList.contains('tb-resizer')) return;
        
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) {
          toggleSelect(id);
        } else {
          selectId(id);
        }
        
        const isClickToEdit = !isEditing && (isPlaceholder || !el.contains(document.activeElement));
        
        if(isClickToEdit){
          setTimeout(() => {
            el.focus();
            isEditing = true;
          }, 10);
          return;
        }
        
        if(!isEditing) {
          startTextboxDrag(e, textboxObj);
        }
        
        e.stopPropagation();
      });

      // Resizer
      const rh = document.createElement('div'); 
      rh.className = 'tb-resizer'; 
      rh.title = 'Drag to resize';
      el.appendChild(rh);
      
      rh.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = el.offsetWidth;
        const startHeight = el.offsetHeight;
        
        function mousemove(ev){
          const dx = (ev.clientX - startX) / state.zoom;
          const dy = (ev.clientY - startY) / state.zoom;
          const newWidth = Math.max(200, startWidth + dx);
          const newHeight = Math.max(120, startHeight + dy);
          
          el.style.width = newWidth + 'px';
          el.style.height = newHeight + 'px';
        }
        
        function mouseup(){
          window.removeEventListener('mousemove', mousemove);
          window.removeEventListener('mouseup', mouseup);
        }
        
        window.addEventListener('mousemove', mousemove);
        window.addEventListener('mouseup', mouseup);
      });

      board.appendChild(el);
      
      setTimeout(() => {
        el.focus();
        if(isPlaceholder){
          el.innerHTML = '';
          isPlaceholder = false;
        }
      }, 100);

      return textboxObj;
    }

    function startTextboxDrag(e, textboxObj) {
      const el = textboxObj.element;
      const selectedTextboxes = Array.from(state.selection)
        .map(id => getTextboxById(id))
        .filter(t => t && t !== null);
      
      if(selectedTextboxes.length === 0) {
        selectedTextboxes.push(textboxObj);
      }
      
      const startX = e.clientX;
      const startY = e.clientY;
      const startPositions = {};
      
      selectedTextboxes.forEach(t => {
        startPositions[t.id] = {
          x: parseFloat(t.element.style.left),
          y: parseFloat(t.element.style.top)
        };
      });
      
      el.style.cursor = 'grabbing';
      
      function mousemove(ev){
        const dx = (ev.clientX - startX) / state.zoom;
        const dy = (ev.clientY - startY) / state.zoom;
        
        selectedTextboxes.forEach(t => {
          const start = startPositions[t.id];
          t.element.style.left = (start.x + dx) + 'px';
          t.element.style.top = (start.y + dy) + 'px';
        });
      }
      
      function mouseup(){
        el.style.cursor = 'grab';
        window.removeEventListener('mousemove', mousemove);
        window.removeEventListener('mouseup', mouseup);
      }
      
      window.addEventListener('mousemove', mousemove);
      window.addEventListener('mouseup', mouseup);
    }

    // Menu functions
    let canvasContextPoint = {x:0,y:0};
    
    function openCanvasMenu(x,y){
      console.log('Opening canvas menu at', x, y);
      closeMenus();
      canvasMenu.style.left = x+'px'; 
      canvasMenu.style.top = y+'px';
      canvasMenu.classList.add('open');
      canvasContextPoint = screenToWorld(x,y);
      
      canvasMenu.onmousedown = (e)=>e.stopPropagation();
      canvasMenu.onclick = (e)=>{
        const act = e.target.dataset.action; 
        if(!act) return;
        console.log('Canvas menu action:', act);
        closeMenus();
        if(act==='upload-image') document.getElementById('fileImage').click();
        if(act==='upload-video') document.getElementById('fileVideo').click();
        if(act==='upload-pdf') document.getElementById('filePDF').click();
        if(act==='add-google-map') openMapModal();
        if(act==='create-group') createGroup(canvasContextPoint);
        if(act==='create-textbox') createFloatingTextbox(canvasContextPoint);
      };
    }
    
    function openNodeMenu(x,y,node){
      console.log('Opening node menu at', x, y);
      closeMenus();
      nodeMenu.style.left = x+'px'; 
      nodeMenu.style.top = y+'px';
      nodeMenu.classList.add('open');
      
      const toggleBtn = nodeMenu.querySelector('button[data-action="toggle-metadata"]');
      if(node.kind==='image'){
        toggleBtn.style.display='block';
        toggleBtn.textContent = node.metaShown ? 'Close metadata' : 'Show metadata';
      }else{
        toggleBtn.style.display='none';
      }
      
      nodeMenu.onmousedown = (e)=>e.stopPropagation();
      nodeMenu.onclick = (e)=>{
        const act = e.target.dataset.action; 
        if(!act) return;
        console.log('Node menu action:', act);
        closeMenus();
        if(act==='delete'){ deleteNode(node); }
        if(act==='duplicate'){ duplicateNode(node); }
        if(act==='toggle-metadata'){
          if(node.metaShown){
            if(node.metaTextbox){ node.metaTextbox.remove(); node.metaTextbox = null; }
            node.metaShown=false;
          }else{
            node.metaTextbox = createMetadataTextbox(node);
            node.metaShown=true;
          }
        }
        if(act==='open'){
          if(node.kind==='image') window.open(node.assetUrl, '_blank');
          else if(node.kind==='video'){ const v = node.el.querySelector('video'); v && v.play(); }
          else if(node.kind==='pdf') window.open(node.assetUrl, '_blank');
          else if(node.kind==='youtube') window.open(`https://www.youtube.com/watch?v=${node.meta.videoId}`, '_blank');
          else if(node.kind==='map') {
            // Open Google Maps with directions
            const fullUrl = node.meta.fullUrl || `https://www.google.com/maps/dir/${encodeURIComponent(node.meta.start || '')}/${encodeURIComponent(node.meta.destination || '')}`;
            window.open(fullUrl, '_blank');
          }
          else if(node.kind==='website') {
            // Open the original website URL
            const originalUrl = node.meta.originalUrl || node.assetUrl;
            window.open(originalUrl, '_blank');
          }
        }
      };
    }

    function openTextboxMenu(x, y, textboxObj){
      console.log('Opening textbox menu at', x, y);
      closeMenus();
      textboxMenu.style.left = x + 'px';
      textboxMenu.style.top = y + 'px';
      textboxMenu.classList.add('open');
      
      textboxMenu.onmousedown = (e) => e.stopPropagation();
      textboxMenu.onclick = (e) => {
        const act = e.target.dataset.action;
        if(!act) return;
        console.log('Textbox menu action:', act);
        closeMenus();
        if(act === 'delete') {
          removeTextbox(textboxObj);
        }
        if(act === 'duplicate') {
          duplicateTextbox(textboxObj);
        }
      };
    }
    
    function closeMenus(){ 
      canvasMenu.classList.remove('open'); 
      nodeMenu.classList.remove('open'); 
      textboxMenu.classList.remove('open'); 
    }

    function removeTextbox(textboxObj) {
      textboxObj.element.remove();
      state.textboxes = state.textboxes.filter(t => t !== textboxObj);
      state.selection.delete(textboxObj.id);
    }

    function duplicateTextbox(textboxObj) {
      const originalEl = textboxObj.element;
      const newPos = {
        x: parseFloat(originalEl.style.left) + 20,
        y: parseFloat(originalEl.style.top) + 20
      };
      
      const newTextbox = createFloatingTextbox(newPos);
      newTextbox.element.style.width = originalEl.style.width;
      newTextbox.element.style.height = originalEl.style.height;
      newTextbox.element.innerHTML = originalEl.innerHTML;
      newTextbox.element.blur();
      
      return newTextbox;
    }

    // Node creation
    function createNode(kind, assetUrl, size, at, extraMeta){
      const id = 'n'+(state.nextId++);
      const node = { 
        id, kind, x: at.x, y: at.y, w: size.w, h: size.h, assetUrl, textboxes:[], 
        meta: extraMeta||{}, metaShown:false, metaTextbox: null,
        title: generateNodeTitle(kind, extraMeta)
      };
      state.nodes.push(node);

      const el = document.createElement('div');
      el.className = `node ${kind}`;
      el.dataset.id = id;
      el.style.left = node.x+'px'; el.style.top = node.y+'px';
      el.style.width = node.w+'px'; el.style.height = node.h+'px';

      const title = document.createElement('div'); 
      title.className='title'; 
      title.textContent = node.title; 
      el.appendChild(title);

      const content = document.createElement('div'); 
      content.className='content'; 
      content.setAttribute('draggable','false'); 
      el.appendChild(content);
      
      if(kind==='image'){ 
        const img = document.createElement('img'); 
        img.src = assetUrl; 
        img.draggable=false; 
        content.appendChild(img); 
      }
      else if(kind==='video'){ 
        const vid = document.createElement('video'); 
        vid.src = assetUrl; 
        vid.controls = true; 
        vid.draggable=false; 
        content.appendChild(vid); 
      }
      else if(kind==='pdf'){ 
        const emb = document.createElement('embed'); 
        emb.src = assetUrl; 
        emb.type='application/pdf'; 
        emb.draggable=false; 
        content.appendChild(emb); 
      }
      else if(kind==='youtube'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        content.appendChild(iframe);
      }
      else if(kind==='map'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        iframe.loading = 'lazy';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        content.appendChild(iframe);
      }
      else if(kind==='website'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        iframe.loading = 'lazy';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox';
        content.appendChild(iframe);
      }

      const toolbar = document.createElement('div'); 
      toolbar.className='toolbar';
      
      if(kind==='image'){
        const metaBtn = document.createElement('button'); 
        metaBtn.textContent='Show metadata';
        metaBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(node.metaShown){
            if(node.metaTextbox){ node.metaTextbox.remove(); node.metaTextbox = null; }
            node.metaShown = false; 
            metaBtn.textContent='Show metadata';
          }else{
            const box = createMetadataTextbox(node);
            node.metaTextbox = box;
            node.metaShown = true; 
            metaBtn.textContent='Close metadata';
          }
        });
        toolbar.appendChild(metaBtn);
      }
      el.appendChild(toolbar);

      setupTitleRename(title, node);

      if(kind==='image' || kind==='youtube' || kind==='pdf' || kind==='map' || kind==='website'){
        const res = document.createElement('div'); 
        res.title="Resize";
        res.style.position='absolute'; res.style.width='12px'; res.style.height='12px';
        res.style.right='-6px'; res.style.bottom='-6px'; res.style.background='var(--handle-bg)';
        res.style.border='2px solid var(--handle-border)'; res.style.borderRadius='50%'; 
        res.style.cursor='nwse-resize'; res.style.zIndex='3';
        el.appendChild(res);
        
        res.addEventListener('mousedown', (e)=>{
          e.stopPropagation();
          const start = {x:e.clientX, y:e.clientY, w:node.w, h:node.h};
          function mm(ev){
            const dx = (ev.clientX-start.x)/state.zoom;
            const dy = (ev.clientY-start.y)/state.zoom;
            node.w = Math.max(160, start.w + dx); 
            node.h = Math.max(120, start.h + dy);
            el.style.width = node.w+'px'; 
            el.style.height = node.h+'px';
            if(node.metaTextbox){
              node.metaTextbox.style.left = (node.w + 16) + 'px';
            }
          }
          function up(){ 
            window.removeEventListener('mousemove', mm); 
            window.removeEventListener('mouseup', up); 
          }
          window.addEventListener('mousemove', mm); 
          window.addEventListener('mouseup', up);
        });
      }

      board.appendChild(el);
      node.el = el;
      enableNodeInteractions(node);
      return node;
    }

    function setupTitleRename(titleEl, item) {
      let isRenaming = false;
      
      titleEl.addEventListener('click', (e)=>{
        e.stopPropagation();
        startRename();
      });
      
      function startRename(){
        if(isRenaming) return;
        isRenaming = true;
        
        const originalText = titleEl.textContent;
        titleEl.classList.add('editing');
        titleEl.contentEditable = true;
        titleEl.focus();
        
        const range = document.createRange();
        range.selectNodeContents(titleEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        
        function finishRename(){
          isRenaming = false;
          titleEl.contentEditable = false;
          titleEl.classList.remove('editing');
          
          const newText = titleEl.textContent.trim();
          if(newText && newText !== originalText){
            item.title = newText;
          } else {
            titleEl.textContent = originalText;
          }
        }
        
        function handleClickOutside(e) {
          if (!titleEl.contains(e.target)) {
            finishRename();
            document.removeEventListener('click', handleClickOutside);
          }
        }
        
        titleEl.addEventListener('blur', finishRename, {once: true});
        titleEl.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            titleEl.blur();
          }
          if(e.key === 'Escape'){
            titleEl.textContent = originalText;
            titleEl.blur();
          }
          e.stopPropagation();
        });
        
        setTimeout(() => {
          document.addEventListener('click', handleClickOutside);
        }, 10);
      }
    }

    function generateNodeTitle(kind, meta) {
      if(kind === 'youtube' && meta && meta.videoId) {
        return meta.isShorts ? 'YouTube Shorts' : 'YouTube Video';
      }
      if(kind === 'map' && meta && meta.start && meta.destination) {
        const shortStart = meta.start.length > 15 ? meta.start.substring(0, 12) + "..." : meta.start;
        const shortDest = meta.destination.length > 15 ? meta.destination.substring(0, 12) + "..." : meta.destination;
        return `${shortStart} → ${shortDest}`;
      }
      if(kind === 'website' && meta && meta.domain) {
        return meta.domain.length > 25 ? meta.domain.substring(0, 22) + "..." : meta.domain;
      }
      if(meta && meta.file && meta.file.name) {
        let name = meta.file.name.replace(/\.[^/.]+$/, "");
        return name.length > 25 ? name.substring(0, 22) + "..." : name;
      }
      
      const kindNames = {
        image: 'Image',
        video: 'Video', 
        pdf: 'Document',
        youtube: 'YouTube Video',
        map: 'Google Map',
        website: 'Website'
      };
      
      return kindNames[kind] || 'Media';
    }

    function createMetadataTextbox(node){
      const meta = node.meta || {};
      const file = meta.file || {};
      const exif = meta.exif || null;
      const wrap = document.createElement('div');
      wrap.className='textbox metadata';
      wrap.contentEditable='false';
      wrap.style.left = (node.w + 16) + 'px';
      wrap.style.top = '0px';

      const kv = (k,v)=> `<div>${k}</div><div>${v ?? '-'}</div>`;
      const fileInfo = `
        <div class="section-title">File info</div>
        <div class="kv">
          ${kv('Name', file.name || '-')}
          ${kv('Type', file.type || '-')}
          ${kv('Size', formatSize(file.size))}
          ${kv('Dimensions', meta.dimensions ? meta.dimensions.w+'×'+meta.dimensions.h : '-')}
        </div>
      `;
      let exifInfo = `<div class="section-title">EXIF info</div>`;
      if(exif){
        exifInfo += `<div class="kv">
          ${kv('Camera', [exif.Make, exif.Model].filter(Boolean).join(' ') || '-')}
          ${kv('Lens', exif.LensModel || '-')}
          ${kv('Focal', exif.FocalLength ? exif.FocalLength+'mm' : '-')}
          ${kv('Exposure', exif.ExposureTime ? exif.ExposureTime+'s' : '-')}
          ${kv('Aperture', exif.FNumber ? 'f/'+exif.FNumber : '-')}
          ${kv('ISO', exif.ISO || '-')}
          ${kv('Taken', exif.DateTimeOriginal || '-')}
        </div>`;
      }else{
        exifInfo += `<div class="kv"><div>EXIF</div><div>No EXIF data found</div></div>`;
      }
      wrap.innerHTML = fileInfo + exifInfo;

      const rh = document.createElement('div'); 
      rh.className='tb-resizer'; 
      wrap.appendChild(rh);
      rh.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        const start = {x:e.clientX, y:e.clientY, w:wrap.offsetWidth, h:wrap.offsetHeight};
        function mm(ev){
          const dx = (ev.clientX-start.x)/state.zoom;
          const dy = (ev.clientY-start.y)/state.zoom;
          const w = Math.max(240, start.w + dx), h = Math.max(140, start.h + dy);
          wrap.style.width = w+'px'; wrap.style.height = h+'px';
        }
        function up(){ 
          window.removeEventListener('mousemove', mm); 
          window.removeEventListener('mouseup', up); 
        }
        window.addEventListener('mousemove', mm); 
        window.addEventListener('mouseup', up);
      });

      node.el.appendChild(wrap);
      return wrap;
    }

    function formatSize(bytes){
      if(!bytes && bytes!==0) return '-';
      const kb = bytes/1024, mb = kb/1024;
      return mb>=1 ? mb.toFixed(2)+' MB' : kb.toFixed(1)+' KB';
    }

    function createGroup(at){
      const id = 'g'+(state.nextId++);
      const g = { id, x: at.x, y: at.y, w: 420, h: 280, color:'#3b82f6', title:'Group '+id };
      state.groups.push(g);
      const el = document.createElement('div'); 
      el.className='group'; 
      el.dataset.id=id;
      el.style.left=g.x+'px'; 
      el.style.top=g.y+'px'; 
      el.style.width=g.w+'px'; 
      el.style.height=g.h+'px';
      el.style.borderColor = g.color;
      const title = document.createElement('div'); 
      title.className='title'; 
      title.textContent=g.title; 
      el.appendChild(title);
      const res = document.createElement('div'); 
      res.className='resizer'; 
      el.appendChild(res);
      
      setupTitleRename(title, g);
      
      board.appendChild(el);
      g.el = el;
      enableGroupInteractions(g);
      return g;
    }

    function enableNodeInteractions(node){
      const el = node.el;
      el.addEventListener('mousedown', (e)=>{
        if(e.button!==0) return;
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) toggleSelect(node.id); else selectId(node.id);
        startDragSelection(e);
        e.stopPropagation();
      });
    }

    function enableGroupInteractions(g){
      const el = g.el;
      el.addEventListener('mousedown', (e)=>{
        if(e.button!==0) return;
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) toggleSelect(g.id); else selectId(g.id);
        startDragSelection(e);
        e.stopPropagation();
      });
      
      const res = el.querySelector('.resizer');
      res.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        const start = {x:e.clientX, y:e.clientY, w:g.w, h:g.h};
        function mm(ev){
          const dx = (ev.clientX-start.x)/state.zoom;
          const dy = (ev.clientY-start.y)/state.zoom;
          g.w = Math.max(200, start.w + dx); 
          g.h = Math.max(160, start.h + dy);
          el.style.width = g.w+'px'; 
          el.style.height = g.h+'px';
        }
        function up(){ 
          window.removeEventListener('mousemove', mm); 
          window.removeEventListener('mouseup', up); 
        }
        window.addEventListener('mousemove', mm); 
        window.addEventListener('mouseup', up);
      });
    }

    function startDragSelection(e){
      const start = {x:e.clientX, y:e.clientY};
      const selected = Array.from(state.selection);
      const startRects = {};
      
      selected.forEach(sid=>{
        const n = getNodeById(sid); 
        const g = getGroupById(sid);
        const t = getTextboxById(sid);
        if(n) startRects[sid] = {x:n.x, y:n.y};
        if(g) startRects[sid] = {x:g.x, y:g.y};
        if(t) startRects[sid] = {x:parseFloat(t.element.style.left), y:parseFloat(t.element.style.top)};
      });
      
      function mm(ev){
        const dx = (ev.clientX-start.x)/state.zoom;
        const dy = (ev.clientY-start.y)/state.zoom;
        selected.forEach(sid=>{
          const n = getNodeById(sid); 
          const g = getGroupById(sid);
          const t = getTextboxById(sid);
          if(n){ 
            n.x = startRects[sid].x + dx; 
            n.y = startRects[sid].y + dy; 
            n.el.style.left = n.x+'px'; 
            n.el.style.top = n.y+'px'; 
          }
          if(g){ 
            g.x = startRects[sid].x + dx; 
            g.y = startRects[sid].y + dy; 
            g.el.style.left = g.x+'px'; 
            g.el.style.top = g.y+'px'; 
          }
          if(t){
            const newX = startRects[sid].x + dx;
            const newY = startRects[sid].y + dy;
            t.element.style.left = newX + 'px';
            t.element.style.top = newY + 'px';
          }
        });
      }
      function up(){ 
        window.removeEventListener('mousemove', mm); 
        window.removeEventListener('mouseup', up); 
      }
      window.addEventListener('mousemove', mm); 
      window.addEventListener('mouseup', up);
    }

    function beginMarquee(e){
      clearSelection();
      const start = screenToWorld(e.clientX, e.clientY);
      const rectEl = document.createElement('div'); 
      rectEl.className='marquee'; 
      board.appendChild(rectEl);
      
      function mm(ev){
        const cur = screenToWorld(ev.clientX, ev.clientY);
        const x = Math.min(start.x, cur.x), y=Math.min(start.y, cur.y);
        const w = Math.abs(cur.x-start.x), h=Math.abs(cur.y-start.y);
        rectEl.style.left=x+'px'; rectEl.style.top=y+'px'; 
        rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
        clearSelection();
        let anyNode=false;
        state.nodes.forEach(n=>{ 
          if(intersects({x,y,w,h}, n)){ selectId(n.id, true); anyNode=true; } 
        });
        if(!anyNode) {
          state.groups.forEach(g=>{ 
            if(intersects({x,y,w,h}, g)) selectId(g.id, true); 
          });
          state.textboxes.forEach(t=>{
            const tx = parseFloat(t.element.style.left);
            const ty = parseFloat(t.element.style.top);
            const tw = t.element.offsetWidth;
            const th = t.element.offsetHeight;
            if(intersects({x,y,w,h}, {x:tx,y:ty,w:tw,h:th})) selectId(t.id, true);
          });
        }
      }
      function up(){
        rectEl.remove();
        window.removeEventListener('mousemove', mm);
        window.removeEventListener('mouseup', up);
      }
      window.addEventListener('mousemove', mm);
      window.addEventListener('mouseup', up);
    }

    // Helper functions
    function screenToWorld(sx, sy){
      const rect = viewport.getBoundingClientRect();
      const x = (sx - rect.left - state.origin.x) / state.zoom;
      const y = (sy - rect.top - state.origin.y) / state.zoom;
      return {x,y};
    }
    
    function intersects(a,b){ 
      return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.h+a.y > b.y; 
    }
    
    function clearSelection(){ 
      state.selection.forEach(id=>{
        const el = getElement(id);
        if(el) el.classList.remove('selected');
      }); 
      state.selection.clear(); 
    }
    
    function selectId(id, additive=false){ 
      if(!additive) clearSelection(); 
      state.selection.add(id); 
      const el = getElement(id);
      if(el) el.classList.add('selected');
    }
    
    function toggleSelect(id){ 
      const el = getElement(id);
      if(state.selection.has(id)){ 
        state.selection.delete(id); 
        if(el) el.classList.remove('selected'); 
      } else { 
        state.selection.add(id); 
        if(el) el.classList.add('selected'); 
      } 
    }
    
    function getElement(id){ return document.querySelector(`[data-id="${id}"]`); }
    function getNodeById(id){ return state.nodes.find(n=>n.id===id); }
    function getGroupById(id){ return state.groups.find(g=>g.id===id); }
    function getTextboxById(id){ return state.textboxes.find(t=>t.id===id); }
    function getTextboxByElement(element){ return state.textboxes.find(t=>t.element===element); }

    function deleteNode(node){ 
      node.el.remove(); 
      state.nodes = state.nodes.filter(n=>n!==node); 
      state.selection.delete(node.id); 
    }
    
    function duplicateNode(node){ 
      const at = {x: node.x + 20, y: node.y + 20}; 
      createNode(node.kind, node.assetUrl, {w: node.w, h: node.h}, at, node.meta); 
    }

    // File handling
    function handleFiles(fileList, atPos){
      console.log('Handling files:', fileList.length);
      if(!fileList || !fileList.length) return;
      let pos = atPos;
      if(!pos){
        const rect = viewport.getBoundingClientRect();
        pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      }
      const offsetStep = 24;
      let idx = 0;
      Array.from(fileList).forEach(async (f)=>{
        const url = URL.createObjectURL(f);
        const kind = fileKindFromMime(f.type);
        let size = {w:360, h:240};
        
        if(kind==='video'){ size = {w:480, h:270}; }
        if(kind==='pdf'){ size = {w:420, h:300}; }

        const at = {x: pos.x - size.w/2 + (idx%5)*offsetStep, y: pos.y - size.h/2 + Math.floor(idx/5)*offsetStep};

        let extraMeta = { file: { name: f.name, type: f.type, size: f.size }, dimensions: null, exif: null };
        
        if(kind==='image'){
          await new Promise((resolve)=>{
            const img = new Image();
            img.onload = ()=>{ 
              const naturalW = img.naturalWidth;
              const naturalH = img.naturalHeight;
              extraMeta.dimensions = {w: naturalW, h: naturalH};
              size = calculateOptimalImageSize(naturalW, naturalH);
              at.x = pos.x - size.w/2 + (idx%5)*offsetStep;
              at.y = pos.y - size.h/2 + Math.floor(idx/5)*offsetStep;
              resolve(); 
            };
            img.onerror = ()=> resolve();
            img.src = url;
          });
        }

        createNode(kind, url, size, at, extraMeta);
        idx++;
      });
    }

    function calculateOptimalImageSize(naturalWidth, naturalHeight) {
      const maxDisplayWidth = 800;
      const maxDisplayHeight = 600;
      const minDisplayWidth = 160;
      const minDisplayHeight = 120;
      
      let displayWidth = naturalWidth;
      let displayHeight = naturalHeight;
      
      if (naturalWidth > maxDisplayWidth || naturalHeight > maxDisplayHeight) {
        const widthRatio = maxDisplayWidth / naturalWidth;
        const heightRatio = maxDisplayHeight / naturalHeight;
        const scale = Math.min(widthRatio, heightRatio);
        
        displayWidth = Math.round(naturalWidth * scale);
        displayHeight = Math.round(naturalHeight * scale);
      }
      
      if (naturalWidth < minDisplayWidth && naturalHeight < minDisplayHeight) {
        const widthRatio = minDisplayWidth / naturalWidth;
        const heightRatio = minDisplayHeight / naturalHeight;
        const scale = Math.min(widthRatio, heightRatio, 3);
        
        displayWidth = Math.round(naturalWidth * scale);
        displayHeight = Math.round(naturalHeight * scale);
      }
      
      displayWidth = Math.max(displayWidth, minDisplayWidth);
      displayHeight = Math.max(displayHeight, minDisplayHeight);
      
      return { w: displayWidth, h: displayHeight };
    }

    function fileKindFromMime(mime){
      if(mime.startsWith('image/')) return 'image';
      if(mime.startsWith('video/')) return 'video';
      if(mime==='application/pdf') return 'pdf';
      return 'image';
    }

    // Save/Load functions with full functionality and base64 file preservation
    function saveBoard(){
      console.log('Saving board...');
      const name = prompt('Enter a name for this board:', `Board_${new Date().toLocaleDateString()}`);
      if(!name) return;
      
      exportBoardDataWithFiles().then(boardData => {
        // Save to localStorage
        const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
        savedBoards[name] = {
          data: boardData,
          timestamp: new Date().toISOString(),
          name: name
        };
        localStorage.setItem('moodboards', JSON.stringify(savedBoards));
        
        // Update the saved boards list
        updateSavedBoardsList();
        
        alert(`Board "${name}" saved successfully with all file data!`);
      }).catch(error => {
        console.error('Save error:', error);
        alert('Error saving board: ' + error.message);
      });
    }

    function exportBoard(){
      console.log('Exporting board...');
      
      // Show progress indicator
      const originalText = document.querySelector('#btnExport').textContent;
      document.querySelector('#btnExport').textContent = 'Exporting...';
      
      exportBoardDataWithFiles().then(boardData => {
        // Create downloadable JSON file
        const dataStr = JSON.stringify(boardData, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `moodboard_export_${new Date().toISOString().split('T')[0]}.json`;
        link.click();
        
        document.querySelector('#btnExport').textContent = originalText;
        alert('Board exported successfully with all file data! Check your downloads folder.');
      }).catch(error => {
        console.error('Export error:', error);
        document.querySelector('#btnExport').textContent = originalText;
        alert('Error exporting board: ' + error.message);
      });
    }

    function importBoard(event){
      console.log('Importing board...');
      const file = event.target.files[0];
      if(!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const boardData = JSON.parse(e.target.result);
          loadBoardData(boardData);
          alert('Board imported successfully with all file data restored!');
        } catch (error) {
          console.error('Import error:', error);
          alert('Error importing board: Invalid JSON file');
        }
      };
      reader.readAsText(file);
      
      // Reset the file input
      event.target.value = '';
    }

    async function exportBoardDataWithFiles() {
      // Convert file URLs to base64 data
      const processedNodes = await Promise.all(state.nodes.map(async (node) => {
        const processedNode = {...node};
        
        // Remove DOM element reference
        delete processedNode.el;
        delete processedNode.metaTextbox;
        
        // For file-based nodes, convert blob URLs to base64
        if(node.assetUrl && node.assetUrl.startsWith('blob:')) {
          try {
            const base64Data = await blobUrlToBase64(node.assetUrl);
            processedNode.assetUrl = base64Data;
            processedNode.isFileNode = true;
            processedNode.hasBase64Data = true;
          } catch (error) {
            console.error('Error converting file to base64:', error);
            processedNode.assetUrl = '[FILE_CONVERSION_ERROR]';
            processedNode.isFileNode = true;
            processedNode.hasBase64Data = false;
          }
        }
        
        return processedNode;
      }));

      const processedTextboxes = state.textboxes.map(textbox => ({
        id: textbox.id,
        content: textbox.element.innerHTML,
        left: textbox.element.style.left,
        top: textbox.element.style.top,
        width: textbox.element.style.width,
        height: textbox.element.style.height
      }));

      const processedGroups = state.groups.map(group => {
        const processedGroup = {...group};
        delete processedGroup.el;
        return processedGroup;
      });

      return {
        version: '4.3',
        timestamp: new Date().toISOString(),
        hasBase64Files: true,
        viewport: {
          zoom: state.zoom,
          origin: state.origin
        },
        nodes: processedNodes,
        groups: processedGroups,
        textboxes: processedTextboxes,
        nextId: state.nextId
      };
    }

    function blobUrlToBase64(blobUrl) {
      return new Promise((resolve, reject) => {
        fetch(blobUrl)
          .then(response => response.blob())
          .then(blob => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          })
          .catch(reject);
      });
    }

    function base64ToBlob(base64Data) {
      const parts = base64Data.split(',');
      const mimeMatch = parts[0].match(/:(.*?);/);
      const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
      const byteString = atob(parts[1]);
      const byteNumbers = new Array(byteString.length);
      
      for (let i = 0; i < byteString.length; i++) {
        byteNumbers[i] = byteString.charCodeAt(i);
      }
      
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], {type: mime});
    }

    async function loadBoardData(boardData) {
      // Clear current board
      clearBoard();
      
      // Restore viewport
      if(boardData.viewport) {
        state.zoom = boardData.viewport.zoom || 1;
        state.origin = boardData.viewport.origin || {x: 0, y: 0};
        applyTransform();
      }
      
      // Restore nextId
      state.nextId = boardData.nextId || 1;
      
      // Restore groups
      if(boardData.groups) {
        boardData.groups.forEach(groupData => {
          const group = createGroup({x: groupData.x, y: groupData.y});
          Object.assign(group, groupData);
          group.el.style.width = group.w + 'px';
          group.el.style.height = group.h + 'px';
          group.el.style.borderColor = group.color;
          group.el.querySelector('.title').textContent = group.title;
        });
      }
      
      // Restore nodes with base64 file conversion
      if(boardData.nodes) {
        for(const nodeData of boardData.nodes) {
          let assetUrl = nodeData.assetUrl;
          
          // Handle base64 file data
          if(nodeData.isFileNode && nodeData.hasBase64Data && nodeData.assetUrl.startsWith('data:')) {
            try {
              // Convert base64 back to blob URL
              const blob = base64ToBlob(nodeData.assetUrl);
              assetUrl = URL.createObjectURL(blob);
            } catch (error) {
              console.error('Error converting base64 to blob:', error);
              console.warn('Skipping file node with conversion error:', nodeData.title);
              continue;
            }
          } else if(nodeData.isFileNode && !nodeData.hasBase64Data) {
            // Skip file nodes without base64 data
            console.warn('Skipping file node with lost data:', nodeData.title);
            continue;
          }
          
          // Create the node
          const node = createNode(
            nodeData.kind,
            assetUrl,
            {w: nodeData.w, h: nodeData.h},
            {x: nodeData.x, y: nodeData.y},
            nodeData.meta
          );
          
          // Restore additional properties
          node.title = nodeData.title;
          node.el.querySelector('.title').textContent = node.title;
        }
      }
      
      // Restore textboxes
      if(boardData.textboxes) {
        boardData.textboxes.forEach(textboxData => {
          const textbox = createFloatingTextbox({x: 0, y: 0});
          textbox.id = textboxData.id;
          textbox.element.dataset.id = textboxData.id;
          textbox.element.innerHTML = textboxData.content;
          textbox.element.style.left = textboxData.left;
          textbox.element.style.top = textboxData.top;
          textbox.element.style.width = textboxData.width;
          textbox.element.style.height = textboxData.height;
        });
      }
    }

    function clearBoard() {
      // Remove all nodes
      state.nodes.forEach(node => {
        if(node.el) node.el.remove();
      });
      state.nodes = [];
      
      // Remove all groups
      state.groups.forEach(group => {
        if(group.el) group.el.remove();
      });
      state.groups = [];
      
      // Remove all textboxes
      state.textboxes.forEach(textbox => {
        if(textbox.element) textbox.element.remove();
      });
      state.textboxes = [];
      
      // Clear selection
      clearSelection();
    }

    function updateSavedBoardsList() {
      const saveList = document.getElementById('saveList');
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      
      saveList.innerHTML = '';
      
      Object.entries(savedBoards).forEach(([name, boardInfo]) => {
        const item = document.createElement('div');
        item.className = 'save-item';
        
        const date = new Date(boardInfo.timestamp).toLocaleDateString();
        const hasFiles = boardInfo.data && boardInfo.data.hasBase64Files ? ' 📁' : '';
        item.innerHTML = `
          <span>${name}${hasFiles} (${date})</span>
          <div>
            <button onclick="loadSavedBoard('${name}')">Load</button>
            <button onclick="deleteSavedBoard('${name}')" class="danger">Delete</button>
          </div>
        `;
        
        saveList.appendChild(item);
      });
      
      if(Object.keys(savedBoards).length === 0) {
        saveList.innerHTML = '<div style="text-align: center; color: var(--muted); font-size: 12px;">No saved boards</div>';
      }
    }

    function loadSavedBoard(name) {
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      const boardInfo = savedBoards[name];
      
      if(!boardInfo) {
        alert('Board not found!');
        return;
      }
      
      if(confirm(`Load board "${name}"? This will replace your current board.`)) {
        loadBoardData(boardInfo.data);
        alert(`Board "${name}" loaded successfully!`);
      }
    }

    function deleteSavedBoard(name) {
      if(confirm(`Delete board "${name}"? This cannot be undone.`)) {
        const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
        delete savedBoards[name];
        localStorage.setItem('moodboards', JSON.stringify(savedBoards));
        updateSavedBoardsList();
        alert(`Board "${name}" deleted.`);
      }
    }

    function loadSavedBoards(){
      console.log('Loading saved boards list...');
      updateSavedBoardsList();
    }

    // Make functions globally available for onclick handlers
    window.loadSavedBoard = loadSavedBoard;
    window.deleteSavedBoard = deleteSavedBoard;

    // Initialize the app
    console.log('About to initialize...');
    init();
  
// === Shift + Drag to move textboxes (without interfering with typing) ===
(function enableShiftDragTextboxes(){
  document.addEventListener('mousedown', (e)=>{
    const tb = e.target.closest('.textbox');
    if(!tb) return;
    // Ignore the resize handle, and only act when Shift is held
    if (!e.shiftKey || e.target.classList.contains('tb-resizer')) return;

    // Prevent canvas pan/selection; we'll move the textbox itself
    e.preventDefault();
    e.stopPropagation();

    // World-space helpers—assumes screenToWorld(state) exists in app
    function screenToWorldLocal(sx, sy){
      try{
        // If the app exposes a screenToWorld utility on window or via closure, use it.
        if (typeof screenToWorld === 'function') return screenToWorld(sx, sy);
      }catch(_e){}
      // Fallback: compute from global state variables if present
      const vp = document.getElementById('viewport');
      const rect = vp.getBoundingClientRect();
      const zoom = (window.state && window.state.zoom) ? window.state.zoom : 1;
      const origin = (window.state && window.state.origin) ? window.state.origin : {x:0,y:0};
      const x = (sx - rect.left - origin.x) / zoom;
      const y = (sy - rect.top  - origin.y) / zoom;
      return {x,y};
    }

    // Establish starting positions in world coords
    const startWorld = screenToWorldLocal(e.clientX, e.clientY);
    const startLeft = parseFloat(tb.style.left) || 0;
    const startTop  = parseFloat(tb.style.top)  || 0;

    // Visual feedback
    const prevCursor = tb.style.cursor;
    tb.style.cursor = 'grabbing';
    tb.classList.add('dragging');

    // Disable text selection while dragging
    const prevUserSelect = document.body.style.userSelect;
    document.body.style.userSelect = 'none';

    function onMove(ev){
      const w = screenToWorldLocal(ev.clientX, ev.clientY);
      const dx = w.x - startWorld.x;
      const dy = w.y - startWorld.y;
      tb.style.left = (startLeft + dx) + 'px';
      tb.style.top  = (startTop  + dy) + 'px';
    }
    function onUp(){
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onUp);
      tb.style.cursor = prevCursor;
      tb.classList.remove('dragging');
      document.body.style.userSelect = prevUserSelect;
    }
    window.addEventListener('mousemove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp, {passive:false});
  }, true); // capture to beat other handlers
})();

</script>
</body>
</html>
