<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>BlankSpace</title>
  <style>
    /* v4.8 — Fixed textbox loading + EXIF + metadata toggle + YouTube import + save/load + Google Maps + Apple-style background */
    :root{
      --bg:#0f1220; --panel:#161a2b; --text:#e8ecff; --muted:#aab2d5;
      --chip:rgba(255,255,255,.06); --radius:18px; --shadow:0 10px 30px rgba(0,0,0,.45);
      --accent:#8b5cf6; --danger:#ef4444; --group:#3b82f6;
      --handle-bg: rgba(255,255,255,.12); --handle-border: rgba(255,255,255,.55);
      --handle-bg-strong: rgba(255,255,255,.2);
      --node-border: rgba(255,255,255,.18);
      
      /* Apple-style background variables */
      --bg-hue: 220;          /* 200–260 = blue/purple Apple vibe */
      --bg-sat: 28%;          /* overall saturation */
      --bg-light: 12%;        /* base lightness (darker for dark theme) */
      --tile: 4098px;          /* 256/512/1024 */
      --grid-gap: 24px;       /* spacing of the micro dot grid */
      --grain-strength: 0.15; /* 0–0.15 suggested */
      --glow-opacity: 0.55;   /* intensity of aurora layer */
    }
    
    /* === Theme variables for wires & handles === */
    /* Default (dark theme) */
    :root {
      --wire-stroke: rgba(255,255,255,.95);
      --wire-shadow: rgba(0,0,0,.6);
      --handle-bg: rgba(255,255,255,.15);
      --handle-border: rgba(255,255,255,.8);
      --handle-icon: rgba(255,255,255,.95);
      --connect-hover-outline: #60a5fa;
    }
    /* Light theme overrides */
    :root.light, [data-theme="light"], .theme-light, body.light {
      --wire-stroke: rgba(17,17,17,.9) !important;
      --wire-shadow: rgba(0,0,0,.18) !important;
      --handle-bg: #fff !important;
      --handle-border: rgba(0,0,0,.55) !important;
      --handle-icon: rgba(0,0,0,.9) !important;
      --connect-hover-outline: #3b82f6 !important;
    }
    /* Dark theme explicit (redundant but ensures consistency) */
    [data-theme="dark"], .theme-dark, body.dark {
      --wire-stroke: rgba(255,255,255,.95);
      --wire-shadow: rgba(0,0,0,.6);
      --handle-bg: rgba(255,255,255,.15);
      --handle-border: rgba(255,255,255,.8);
      --handle-icon: rgba(255,255,255,.95);
      --connect-hover-outline: #60a5fa;
    }
    /* === Wires layer sits BELOW nodes === */
    #wires {
      position:absolute; left:0; top:0;
      width:50000px; height:50000px;
      pointer-events:none;     /* wires never block */
      z-index:0;               /* behind nodes (which are z-index:auto/1+) */
      filter: drop-shadow(0 0 1px var(--wire-shadow));
    }
    .wire-path {
      fill:none;
      stroke: var(--wire-stroke);
      stroke-width: 3;
      stroke-linecap: round;
      stroke-linejoin: round;
      pointer-events: stroke;
    }
    /* Invisible larger hit area for wire paths */
    .wire-hit-area {
      fill: none;
      stroke: transparent;
      stroke-width: 12;
      stroke-linecap: round;
      stroke-linejoin: round;
      pointer-events: stroke;
      cursor: pointer;
    }
    /* "On-wire" handle groups (drag these) */
    .wire-handle {
      pointer-events:all;
      cursor:grab;
    }
    .wire-handle.dragging { cursor:grabbing; }
    .wire-handle .hit { fill: transparent; r: 18; } /* generous hit area */
    .wire-handle .dot { fill: var(--handle-bg); stroke: var(--handle-border); r: 8; stroke-width: 2; }
    .wire-handle .icon {
      fill: none; stroke: var(--handle-icon); stroke-width: 1.5;
    }
    /* Hover cue for connectable targets */
    .node.connect-hover, .textbox.connect-hover, .checknode.connect-hover {
      outline: 2px solid var(--connect-hover-outline);
      box-shadow: 0 0 0 3px color-mix(in srgb, var(--connect-hover-outline) 35%, transparent);
    }
    :root.light{
      --bg:#f7f8fc; --panel:#ffffff; --text:#0e132f; --muted:#5b627e;
      --chip:rgba(0,0,0,.06); --shadow:0 10px 25px rgba(0,0,0,.12);
      --handle-bg: rgba(0,0,0,.12); --handle-border: rgba(0,0,0,.55);
      --handle-bg-strong: rgba(0,0,0,.2);
      --node-border: rgba(0,0,0,.15);
      
      /* Light theme background adjustments */
      --bg-light: 98%;        /* lighter for light theme */
    }
    *{box-sizing:border-box}
    html,body,#root{height:100%}
    body{
      margin:0;color:var(--text);font:14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;overflow:hidden;
      
      /* Apple-style seamless background */
      background-image:
        /* 1) Micro dot grid (ultra‑subtle) */
        radial-gradient(rgba(255,255,255,.03) 1px, transparent 1.5px),
        /* 2) Fine diagonal fiber */
        repeating-linear-gradient(135deg, rgba(255,255,255,.02) 0 2px, transparent 2px 4px),
        /* 3) Aurora / glow tile (SVG with seamless turbulence) - dark theme */
        url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512'%3E%3Cdefs%3E%3ClinearGradient id='wash' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='hsl(220, 30%25, 15%25)'/%3E%3Cstop offset='100%25' stop-color='hsl(220, 30%25, 8%25)'/%3E%3C/linearGradient%3E%3Cfilter id='aurora' x='-20%25' y='-20%25' width='140%25' height='140%25'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.006' numOctaves='2' seed='8' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='0.8 0 0.2 0 0  0 0.8 0.2 0 0  0.2 0 1.2 0 0  0 0 0 .3 0'/%3E%3CfeComponentTransfer%3E%3CfeFuncR type='gamma' amplitude='1.15' exponent='1.2'/%3E%3CfeFuncG type='gamma' amplitude='1.10' exponent='1.1'/%3E%3CfeFuncB type='gamma' amplitude='1.25' exponent='1.3'/%3E%3C/feComponentTransfer%3E%3CfeGaussianBlur stdDeviation='22'/%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23wash)'/%3E%3Crect width='100%25' height='100%25' filter='url(%23aurora)' opacity='0.4'/%3E%3C/svg%3E"),
        /* 4) Soft base wash (CSS gradient) */
        linear-gradient(
          180deg,
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 2%)),
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 4%))
        );

      background-size:
        var(--grid-gap) var(--grid-gap),            /* dot grid size */
        var(--tile) var(--tile),                    /* diagonal fiber repeats on tile */
        var(--tile) var(--tile),                    /* aurora SVG tile */
        cover;                                      /* base wash fills */

      background-position: 0 0, 0 0, 0 0, 0 0;
      background-repeat: repeat, repeat, repeat, no-repeat;
      background-attachment: fixed;
      
      /* Extra polish for Apple‑ish depth */
      -webkit-font-smoothing: antialiased;
      backface-visibility: hidden;
    }
    
    /* Light theme background override */
    :root.light body{
      background-image:
        /* 1) Micro dot grid (ultra‑subtle) */
        radial-gradient(rgba(0,0,0,.04) 1px, transparent 1.5px),
        /* 2) Fine diagonal fiber */
        repeating-linear-gradient(135deg, rgba(0,0,0,.03) 0 2px, transparent 2px 4px),
        /* 3) Aurora / glow tile (SVG with seamless turbulence) - light theme */
        url("data:image/svg+xml;utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512'%3E%3Cdefs%3E%3ClinearGradient id='wash' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0%25' stop-color='hsl(220, 30%25, 99%25)'/%3E%3Cstop offset='100%25' stop-color='hsl(220, 30%25, 95%25)'/%3E%3C/linearGradient%3E%3Cfilter id='aurora' x='-20%25' y='-20%25' width='140%25' height='140%25'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.006' numOctaves='2' seed='8' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 .75 0'/%3E%3CfeComponentTransfer%3E%3CfeFuncR type='gamma' amplitude='1.15' exponent='1.2'/%3E%3CfeFuncG type='gamma' amplitude='1.10' exponent='1.1'/%3E%3CfeFuncB type='gamma' amplitude='1.25' exponent='1.3'/%3E%3C/feComponentTransfer%3E%3CfeGaussianBlur stdDeviation='22'/%3E%3C/filter%3E%3C/defs%3E%3Crect width='100%25' height='100%25' fill='url(%23wash)'/%3E%3Crect width='100%25' height='100%25' filter='url(%23aurora)' opacity='0.66'/%3E%3C/svg%3E"),
        /* 4) Soft base wash (CSS gradient) */
        linear-gradient(
          180deg,
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 0%)),
          hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 3%))
        );
    }
    .topbar{
      position:fixed; inset:0 0 auto 0; height:64px; display:flex; align-items:center; justify-content:space-between;
      padding:0 16px; background:linear-gradient(180deg, rgba(0,0,0,.3), rgba(0,0,0,0)); z-index:1000; pointer-events:none;
    }
    .topbar .actions button, .topbar select{pointer-events:auto}
    .brand{display:flex; gap:12px; align-items:center}
    .logo{width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg,#74ebd5,#ACB6E5)}
    .title{font-weight:700}
    .subtitle{font-size:12px; color:var(--muted)}
    .actions{display:flex; gap:8px}
    button{
      background:var(--panel); color:var(--text); border:1px solid rgba(255,255,255,.08);
      border-radius:10px; padding:8px 12px; box-shadow:var(--shadow); cursor:pointer;
    }
    button:hover{filter:brightness(1.1)}
    button:active{transform:translateY(1px)}
    button.danger{background:rgba(239,68,68,.15); border-color:rgba(239,68,68,.35)}
    select{background:var(--panel); color:var(--text); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px 12px}

    /* URL Import Panel */
    .url-panel{
      position:fixed; top:80px; left:16px; width:320px; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:16px; box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    .url-panel h3{margin:0 0 12px; font-size:14px; font-weight:600}
    .url-panel input{
      width:100%; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      border-radius:8px; padding:8px 12px; color:var(--text); font-size:14px; margin-bottom:8px;
    }
    .url-panel input:focus{outline:none; border-color:var(--accent)}
    .url-panel .url-buttons{display:flex; gap:8px}
    .url-panel button{padding:6px 12px; font-size:12px}
    .url-panel .url-types{
      font-size:11px; color:var(--muted); margin-bottom:8px; line-height:1.4;
    }

    /* Save/Load Panel */
    .save-panel{
      position:fixed; top:80px; right:16px; width:320px; background:var(--panel); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:16px; box-shadow:var(--shadow); z-index:1500; pointer-events:auto;
      backdrop-filter: blur(10px);
    }
    .save-panel h3{margin:0 0 12px; font-size:14px; font-weight:600}
    .save-panel .save-buttons{display:flex; gap:8px; margin-bottom:12px}
    .save-panel .save-list{max-height:150px; overflow-y:auto}
    .save-item{
      display:flex; justify-content:space-between; align-items:center; padding:8px;
      background:rgba(255,255,255,.04); border-radius:6px; margin-bottom:6px; font-size:12px;
    }
    .save-item button{padding:4px 8px; font-size:11px}

    /* Google Maps Modal */
    .map-modal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      width: 400px; background: var(--panel); border: 1px solid rgba(255,255,255,.08);
      border-radius: 16px; padding: 24px; box-shadow: var(--shadow); z-index: 2000;
      backdrop-filter: blur(20px);
    }
    .map-modal h3 {
      margin: 0 0 16px; font-size: 18px; font-weight: 600; text-align: center;
    }
    .map-modal .input-group {
      margin-bottom: 16px;
    }
    .map-modal label {
      display: block; margin-bottom: 6px; font-size: 14px; font-weight: 500;
    }
    .map-modal input {
      width: 100%; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12);
      border-radius: 8px; padding: 10px 12px; color: var(--text); font-size: 14px;
    }
    .map-modal input:focus {
      outline: none; border-color: var(--accent);
    }
    .map-modal .modal-buttons {
      display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;
    }
    .map-modal button {
      padding: 8px 16px; font-size: 14px;
    }
    .modal-overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 1999;
      backdrop-filter: blur(4px);
    }

    #viewport{position:absolute; inset:0; overflow:hidden; cursor:grab}
    #viewport.dragging{cursor:grabbing}
    #board{position:absolute; inset:auto; transform-origin:0 0; outline:none}

    .node{
      position:absolute; border-radius:20px; background:var(--panel); box-shadow:var(--shadow);
      border:1px solid var(--node-border); overflow:visible; user-select:none; cursor:grab;
    }
    .node:active{cursor:grabbing}
    .node.selected{outline:2px solid var(--accent)}
    .node .content{width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:rgba(255,255,255,.02)}
    .node .toolbar{position:absolute; top:6px; right:6px; display:flex; gap:6px; z-index:1000}
    .node .toolbar button{padding:4px 8px; font-size:12px}

    /* Node title styling - minimal like groups */
    .node .title{
      position:absolute; top:-14px; left:16px; padding:2px 8px; background:var(--panel); 
      border-radius:999px; border:1px solid rgba(255,255,255,.08); font-size:12px;
      max-width:200px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      cursor:pointer; transition:all 0.2s ease;
    }
    .node .title:hover{
      background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15);
    }
    .node .title.editing{
      background:rgba(255,255,255,.1); border-color:var(--accent); outline:1px solid var(--accent);
      cursor:text;
    }

    .node.image img{width:100%; height:100%; object-fit:contain; background:#000}
    .node.video video{width:100%; height:100%; background:#000}
    .node.pdf iframe, .node.pdf embed{width:100%; height:100%; background:#fff}
    .node.youtube iframe{width:100%; height:100%; border:none; border-radius:16px}
    .node.map iframe{width:100%; height:100%; border:none; border-radius:16px}
    .node.website iframe{width:100%; height:100%; border:none; border-radius:16px}

    /* Glassmorphism textbox styling - adapted from glassmorphism file */
    .textbox {
      position: absolute;
      min-width: 120px;
      min-height: 70px;
      cursor: grab;
      z-index: 1600;
      white-space: pre-wrap;
      word-break: break-word;
      text-align: left;
      font-size: 18px;
      line-height: 1.2;
      resize: both;
      overflow: auto;
      scrollbar-color: var(--accent) rgb(255, 255, 255);
      scrollbar-width: thin;
      
      /* Glassmorphism styling */
      padding: 14px 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.35);
      outline: none;
      
      /* Glass base */
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(14px) saturate(160%);
      -webkit-backdrop-filter: blur(14px) saturate(160%);
      
      /* Subtle white-only gradient for depth on the border */
      background-image:
        linear-gradient(rgba(255,255,255,0.10), rgba(255,255,255,0.10)),
        linear-gradient(135deg, rgba(255,255,255,0.85), rgba(255,255,255,0.45));
      background-origin: border-box;
      background-clip: padding-box, border-box;
      
      /* Gentle inner/outer glow to lift from bg */
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.35), /* top bevel */
        inset 0 -1px 0 rgba(255,255,255,0.12), /* bottom shade */
        0 8px 30px rgba(0,0,0,0.35),
        0 0 24px rgba(255,255,255,0.04);
      
      color: var(--text);
      transition: box-shadow .35s ease, transform .35s ease, border-color .35s ease;
    }
    
    /* Animated sheen for texture */
    .textbox::before {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 13px;
      pointer-events: none;
      background:
        radial-gradient(120% 60% at 20% 10%, rgba(255,255,255,0.22), rgba(255,255,255,0) 60%),
        radial-gradient(140% 80% at 80% 120%, rgba(255,255,255,0.10), rgba(255,255,255,0) 60%),
        linear-gradient(115deg, rgba(255,255,255,0.00) 35%, rgba(255,255,255,0.22) 50%, rgba(255,255,255,0.00) 65%);
      background-size: auto, auto, 300% 100%;
      background-position: center center, center center, -150% 0;
      background-repeat: no-repeat;
      mix-blend-mode: screen;
      will-change: background-position;
      animation: textbox-sheen 5.5s ease-in-out infinite;
    }
    
    /* Subtle animated micro-texture */
    .textbox::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 13px;
      pointer-events: none;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.04) 0 1px, rgba(255,255,255,0.00) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0 2px, rgba(255,255,255,0.00) 2px 5px);
      opacity: .7;
      filter: contrast(110%) saturate(120%);
      background-size: 100% 300%, 300% 100%;
      will-change: background-position;
      animation: textbox-micro 14s linear infinite;
    }
    
    @keyframes textbox-sheen {
      0%   { background-position: center center, center center, -150% 0; }
      50%  { background-position: center center, center center, 150% 0; }
      100% { background-position: center center, center center, 150% 0; }
    }
    
    @keyframes textbox-micro {
      0%   { background-position: 0 0, 0 0; }
      100% { background-position: 0 100%, 100% 0; }
    }
    
    .textbox:hover {
      border-color: rgba(255,255,255,.45);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.45),
        inset 0 -1px 0 rgba(255,255,255,0.18),
        0 10px 40px rgba(0,0,0,0.45),
        0 0 36px rgba(255,255,255,0.08);
    }
    
    .textbox:focus {
      outline: none;
      cursor: text !important;
      border-color: rgba(255,255,255,0.6);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.45),
        inset 0 -1px 0 rgba(255,255,255,0.18),
        0 10px 40px rgba(0,0,0,0.45),
        0 0 36px rgba(255,255,255,0.08);
      transform: translateY(-1px);
    }
    
    .textbox.selected {
      border-color: var(--accent);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.45),
        inset 0 -1px 0 rgba(255,255,255,0.18),
        0 8px 24px rgba(0,0,0,.45), 
        0 0 0 2px var(--accent);
    }
    
    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .textbox::before,
      .textbox::after { 
        animation: none; 
      }
    }
    
    /* Make it obvious links are clickable in the textbox */
    .textbox a { 
      text-decoration: underline; 
      cursor: pointer; 
    }
    /* Ensure links are not accidentally "blocked" by overlays */
    .textbox a { 
      pointer-events: auto; 
    }
    
    .textbox .tb-resizer{
      position:absolute; width:12px; height:12px; right:-6px; bottom:-6px; 
      background:var(--handle-bg); border:2px solid var(--handle-border); 
      border-radius:50%; cursor:nwse-resize; z-index: 1700;
      transition: all 0.2s ease;
      opacity: 0.6;
    }
    .textbox:hover .tb-resizer, .textbox.selected .tb-resizer{
      opacity: 1;
      background:var(--handle-bg-strong);
    }
    .textbox .tb-resizer:hover{
      transform: scale(1.2);
    }

    /* Metadata textbox: vertical orientation (narrow column) */
    .textbox.metadata{
      width:280px;
    }
    .textbox .section-title{
      font-weight:700; font-size:18px; opacity:.9; margin:6px 0 4px;
    }
    .textbox .kv{display:grid; grid-template-columns:92px 1fr; gap:4px 8px; font-size:12px; color:var(--muted)}
    .textbox .kv div:nth-child(odd){opacity:.9}
    .textbox .kv div:nth-child(even){color:var(--text)}

    .group{
      position:absolute; border:2px dashed var(--group); border-radius:24px; background:rgba(59,130,246,.06);
    }
    .group .title{
      position:absolute; top:-14px; left:16px; padding:2px 8px; background:var(--panel); border-radius:999px; border:1px solid rgba(255,255,255,.08); font-size:12px;
      cursor:pointer; transition:all 0.2s ease;
    }
    .group .title:hover{
      background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.15);
    }
    .group .title.editing{
      background:rgba(255,255,255,.1); border-color:var(--accent); outline:1px solid var(--accent);
      cursor:text;
    }
    .group.selected{outline:2px solid var(--accent)}
    .group .resizer{position:absolute; width:12px; height:12px; right:-6px; bottom:-6px; background:var(--handle-bg); border:2px solid var(--handle-border); border-radius:50%; cursor:nwse-resize}

    .marquee{position:absolute; border:1px dashed rgba(255,255,255,.6); background:rgba(255,255,255,.1); pointer-events:none}

    .menu{position:absolute; display:none; flex-direction:column; background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:6px; z-index:2000}
    .menu.open{display:flex}
    .menu button{background:transparent; border:none; text-align:left; padding:8px 12px; border-radius:8px}
    .menu button:hover{background:rgba(255,255,255,.06)}
    .menu hr{border:none; border-top:1px solid rgba(255,255,255,.08); margin:6px 0}

    .scale-bar{
      position:fixed; left:12px; bottom:12px; display:flex; align-items:center; gap:10px; z-index:1500;
      background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.1); padding:6px 10px; border-radius:999px; backdrop-filter: blur(6px);
    }
    /* Drag and drop overlay */
    .drop-overlay {
      position: fixed;
      inset: 0;
      background: rgba(139, 92, 246, 0.1);
      border: 3px dashed var(--accent);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
    .drop-overlay.active {
      display: flex;
    }
    .drop-message {
      background: var(--panel);
      padding: 24px 32px;
      border-radius: 16px;
      border: 1px solid var(--accent);
      box-shadow: var(--shadow);
      text-align: center;
      pointer-events: none;
    }
    .drop-message h3 {
      margin: 0 0 8px;
      color: var(--accent);
      font-size: 18px;
      font-weight: 600;
    }
    .drop-message p {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    
    /* ===== Standalone Checklist Node ===== */
    .checknode{
      position:absolute;
      left:200px; top:200px;
      display:flex; align-items:center; gap:.5rem;
      padding:.5rem .75rem;
      border:1px solid var(--node-border);
      background:var(--panel);
      border-radius:.5rem;
      box-shadow:var(--shadow);
      user-select:none;
      color:var(--text);
      cursor:default;
      transition:box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .checknode:hover{
      border-color:rgba(255,255,255,.25);
      box-shadow:0 6px 20px rgba(0,0,0,.3);
    }
    :root.light .checknode:hover{
      border-color:rgba(0,0,0,.2);
      box-shadow:0 6px 20px rgba(0,0,0,.15);
    }
    /* Drag handle (visual grip) */
    .checknode .drag-handle{
      width:10px; height:20px; flex:0 0 10px;
      display:inline-block;
      border-radius:3px;
      background-image:
        radial-gradient(currentColor 1px, transparent 1px),
        radial-gradient(currentColor 1px, transparent 1px);
      background-position: 0 0, 5px 10px;
      background-size: 5px 10px;
      opacity:.65;
      cursor:grab;
      color:var(--muted);
    }
    .checknode .drag-handle:active { cursor:grabbing; }
    .checknode .drag-handle:hover { opacity:.9; }
    .checknode input[type="checkbox"]{
      width:1rem; height:1rem; margin:0; flex:0 0 auto; pointer-events:auto;
      accent-color:var(--accent);
    }
    .checknode .checktext{
      outline:none; min-width:2ch; max-width:36ch;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      user-select:text; cursor:text;
      color:var(--text);
    }
    .checknode .checktext:focus{
      outline:2px solid var(--accent);
      outline-offset:2px;
      border-radius:4px;
    }
  </style>

<style>
/* X (Twitter) node visual parity */
.node.twitter .tweet-host{
  position:relative; z-index:1; border-radius:16px;
  background:#000;
}
</style>
<style>
/* Video node parity */
.node.video .video-host{ border-radius:16px; overflow:hidden; background:#000; }
</style>
<style>

  /* === Floating Text Toolbar (injected) === */
  #textToolbar.ftb { position: fixed; left: -9999px; top: -9999px; z-index: 9999; opacity: 0; pointer-events: none; transition: opacity .18s ease, transform .18s ease; transform: translateY(4px); }
  #textToolbar.ftb.is-visible { opacity: 1; pointer-events: auto; transform: translateY(0); }
  .ftb-row { display:flex; align-items:center; gap:6px; padding:10px; border-radius:22px; background: rgba(30,35,42,.55); backdrop-filter: blur(14px) saturate(160%); -webkit-backdrop-filter: blur(14px) saturate(160%); border:1px solid rgba(255,255,255,.20); box-shadow:0 12px 30px rgba(0,0,0,.45); }
  .ftb-sep { width:1px; height:26px; background:rgba(255,255,255,.18); margin:0 4px; }
  .ftb-btn { min-width:34px; height:34px; padding:0 10px; border:0; border-radius:12px; cursor:pointer; background: rgba(255,255,255,.08); color:#e9eef5; font:600 13px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; display:grid; place-items:center; user-select:none; }
  .ftb-btn:hover { filter: brightness(1.1); }
  .ftb-btn:active { transform: translateY(0.5px); }
  .ftb-btn[disabled]{ opacity:.45; cursor:not-allowed; }
  .ftb-btn.is-active{ outline: 2px solid rgba(255,255,255,.25); }
  .ftb-swatch { width:34px; height:34px; display:grid; place-items:center; border-radius:12px; background:rgba(255,255,255,.08); cursor:pointer; overflow:hidden; }
  .ftb-swatch input[type="color"]{ width:34px; height:34px; border:0; padding:0; background:transparent; appearance:none; }
  .ftb-link, .ftb-select, .ftb-number { height:34px; border-radius:12px; border:1px solid rgba(255,255,255,.20); background: rgba(255,255,255,.06); color:#e9eef5; padding:0 10px; }
  .ftb-link{ width:208px; } .ftb-select{ min-width:150px; } .ftb-number{ width:74px; }
  .ftb-unit{ opacity:.7; font-size:12px; margin-left:-6px; margin-right:4px; }
  #tbFont{ background:#fff; color:#111827; border-color:#fff; font-weight:600; }
  #tbFont:focus{ outline:2px solid #fff; }
  /* === End Floating Text Toolbar === */

</style>
<style>

  /* === Floating Spotlight Search (injected) === */
  #spotlightOverlay {
    position: fixed; inset: 0;
    background: rgba(0,0,0,.45);
    backdrop-filter: blur(10px) saturate(140%);
    -webkit-backdrop-filter: blur(10px) saturate(140%);
    display: none;
    align-items: center; justify-content: center;
    z-index: 10000;
  }
  #spotlightOverlay.is-open { display: flex; }
  .spotlight-card {
    width: min(720px, 92vw);
    border-radius: 18px;
    background: rgba(30,35,42,.92);
    border: 1px solid rgba(255,255,255,.18);
    box-shadow: 0 24px 70px rgba(0,0,0,.6);
    padding: 16px;
  }
  .spotlight-row {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    align-items: center;
  }
  .spotlight-input {
    height: 44px;
    border: 1px solid rgba(255,255,255,.25);
    background: rgba(255,255,255,.06);
    color: #e9eef5;
    border-radius: 12px;
    padding: 0 14px;
    font: 600 15px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    outline: none;
  }
  .spotlight-input::placeholder { color: #b3c0cf; }
  .spotlight-btn {
    height: 44px; padding: 0 14px;
    border: 0; border-radius: 12px;
    background: white; color: #111827;
    font: 700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    cursor: pointer;
  }
  .spotlight-hint {
    margin-top: 10px; font-size: 12px; color: #b3c0cf;
    display: flex; justify-content: space-between;
  }
  .kbd { 
    display:inline-grid; place-items:center; 
    min-width: 22px; height: 22px; padding: 0 6px;
    background: rgba(255,255,255,.14); color: #e9eef5; 
    border-radius: 6px; font-weight: 700; 
    border: 1px solid rgba(255,255,255,.22);
  }
  /* === End Spotlight Search === */

</style>
<style>

  /* === Canvas Bottom-Center Description (injected) === */
  /* Fallback when appended to <body> */
  #canvasDescription {
    position: fixed;
    left: 50%;
    bottom: 12px;
    transform: translateX(-50%);
    z-index: 9000;
    color: #b3c0cf;
    font: 700 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    letter-spacing: .02em;
    opacity: .85;
    text-shadow: 0 1px 1px rgba(0,0,0,.35);
    pointer-events: none; /* never blocks canvas interactions */
    user-select: none;
    background: transparent;
    border: 0;
    padding: 0;
  }
  /* Preferred when inside #viewport (canvas) */
  #viewport #canvasDescription {
    position: absolute;
    left: 50%;
    bottom: 12px;
    transform: translateX(-50%);
  }
  /* === End Description === */

</style>

<style id="oscar-black-gold">
  /* === Oscar Black & Gold — Dark Mode Overrides === */
  html:not(.light) {
    --bg:#0b0b10;
    --panel:#111114;
    --text:#F8F5EC;
    --muted:#C8B88A;
    --chip: rgba(241,200,72,.06);
    --shadow: 0 10px 30px rgba(0,0,0,.6);
    --accent:#D4AF37;        /* metallic gold */
    --group:#B08900;
    --danger:#f05252;
    --node-border: rgba(212,175,55,.22);
    --handle-bg: rgba(212,175,55,.18);
    --handle-border: rgba(212,175,55,.75);
    --handle-bg-strong: rgba(212,175,55,.28);
    --handle-icon: rgba(255,239,180,.95);
    --wire-stroke: rgba(255,215,96,.95);
    --wire-shadow: rgba(0,0,0,.7);
    --connect-hover-outline: #FFD35B;

    /* Warm background tuning */
    --bg-hue: 46;
    --bg-sat: 18%;
    --bg-light: 10%;
  }

  /* Replace dark background stack with a gold-tinted version */
  html:not(.light) body {
    background-image:
      /* 1) Micro dot grid */
      radial-gradient(rgba(255,215,128,.08) 1px, transparent 1.5px),
      /* 2) Fine diagonal fiber */
      repeating-linear-gradient(135deg, rgba(255,220,160,.03) 0 2px, transparent 2px 4px),
      /* 3) Gold aurora tile */
      url("data:image/svg+xml;utf8,%3Csvg xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg' width%3D'512' height%3D'512'%3E%0A%3Cdefs%3E%0A  %3ClinearGradient id%3D'wash' x1%3D'0' y1%3D'0' x2%3D'1' y2%3D'1'%3E%0A    %3Cstop offset%3D'0%' stop-color%3D'hsl(45, 18%, 12%)'%2F%3E%0A    %3Cstop offset%3D'100%' stop-color%3D'hsl(45, 18%, 7%)'%2F%3E%0A  %3C%2FlinearGradient%3E%0A  %3Cfilter id%3D'aurora' x%3D'-20%' y%3D'-20%' width%3D'140%' height%3D'140%'%3E%0A    %3CfeTurbulence type%3D'fractalNoise' baseFrequency%3D'0.006' numOctaves%3D'2' seed%3D'12' stitchTiles%3D'stitch'%2F%3E%0A    %3CfeColorMatrix type%3D'matrix' %0A      values%3D'1 0.10 0 0 0   0.85 0.75 0 0 0   0.05 0.05 0.55 0 0   0 0 0 .35 0'%2F%3E%0A    %3CfeGaussianBlur stdDeviation%3D'22'%2F%3E%0A  %3C%2Ffilter%3E%0A%3C%2Fdefs%3E%0A%3Crect width%3D'100%' height%3D'100%' fill%3D'url(%23wash)'%2F%3E%0A%3Crect width%3D'100%' height%3D'100%' filter%3D'url(%23aurora)' opacity%3D'0.50'%2F%3E%0A%3C%2Fsvg%3E"),
      /* 4) Base wash driven by vars */
      linear-gradient(
        180deg,
        hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) + 2%)),
        hsl(var(--bg-hue) var(--bg-sat) calc(var(--bg-light) - 4%))
      );
  }

  /* Topbar + logo */
  html:not(.light) .topbar {
    background: linear-gradient(180deg, rgba(212,175,55,.25), rgba(0,0,0,0));
  }
  html:not(.light) .logo {
    background: linear-gradient(135deg,#2a2000,#D4AF37);
    box-shadow: 0 6px 18px rgba(212,175,55,.25), inset 0 0 0 1px rgba(255,255,255,.05);
  }

  /* Buttons, selects, menus */
  html:not(.light) button,
  html:not(.light) select {
    background: var(--panel);
    color: var(--text);
    border: 1px solid rgba(212,175,55,.28);
    box-shadow: 0 12px 30px rgba(0,0,0,.45);
  }
  html:not(.light) button:hover,
  html:not(.light) select:hover {
    filter: none;
    box-shadow: 0 0 0 1px rgba(212,175,55,.35) inset, 0 0 24px rgba(212,175,55,.12);
  }
  html:not(.light) button.danger {
    background: rgba(240,82,82,.12);
    border-color: rgba(240,82,82,.35);
  }

  /* Menus */
  html:not(.light) .menu {
    border-color: rgba(212,175,55,.22);
  }
  html:not(.light) .menu button:hover {
    background: rgba(212,175,55,.12);
  }
  html:not(.light) .menu hr {
    border-top-color: rgba(212,175,55,.25);
  }

  /* Nodes, groups, titles */
  html:not(.light) .node {
    border-color: var(--node-border);
  }
  html:not(.light) .node .title {
    border-color: rgba(212,175,55,.25);
    background: rgba(212,175,55,.06);
  }
  html:not(.light) .group {
    border-color: var(--group);
    background: rgba(212,175,55,.06);
  }

  /* Textboxes — subtle golden glass */
  html:not(.light) .textbox {
    border-color: rgba(212,175,55,.45);
    background: rgba(255,255,255,0.06);
    box-shadow:
      inset 0 1px 0 rgba(255,245,200,0.35),
      inset 0 -1px 0 rgba(212,175,55,0.18),
      0 8px 30px rgba(0,0,0,0.45),
      0 0 24px rgba(212,175,55,0.10);
  }
  html:not(.light) .textbox:hover {
    border-color: rgba(212,175,55,.6);
    box-shadow:
      inset 0 1px 0 rgba(255,245,200,0.45),
      inset 0 -1px 0 rgba(212,175,55,0.25),
      0 10px 40px rgba(0,0,0,0.5),
      0 0 36px rgba(212,175,55,0.14);
  }
  html:not(.light) .textbox.selected {
    box-shadow:
      inset 0 1px 0 rgba(255,245,200,0.45),
      inset 0 -1px 0 rgba(212,175,55,0.18),
      0 8px 24px rgba(0,0,0,.5),
      0 0 0 2px var(--accent);
  }

  /* Check node hover */
  html:not(.light) .checknode:hover {
    border-color: rgba(212,175,55,.35);
    box-shadow: 0 6px 20px rgba(0,0,0,.35);
  }

  /* Contextual overlays */
  html:not(.light) .drop-overlay {
    background: rgba(212,175,55, 0.10);
    border-color: var(--accent);
  }
  html:not(.light) .drop-message {
    border-color: var(--accent);
  }

  /* Scale bar */
  html:not(.light) .scale-bar {
    background: rgba(212,175,55,.12);
    border: 1px solid rgba(212,175,55,.25);
  }

  /* Spotlight search */
  html:not(.light) #spotlightOverlay {
    background: rgba(0,0,0,.5);
  }
  html:not(.light) .spotlight-card {
    background: rgba(20,18,12,.92);
    border: 1px solid rgba(212,175,55,.28);
  }
  html:not(.light) .spotlight-input {
    border: 1px solid rgba(212,175,55,.35);
    background: rgba(212,175,55,.06);
    color: var(--text);
  }
  html:not(.light) .spotlight-input:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(212,175,55,.45);
    border-color: var(--accent);
  }
  html:not(.light) .spotlight-btn {
    background: var(--accent);
    color: #121212;
  }
</style>

<style id="oscar-black-gold-rim">
  /* === Oscar — Black Canvas, Gold Rim (Dark Mode Only) === */
  html:not(.light) {
    --bg:#0a0a0b;
    --panel:#111214;
    --text:#ECEDEF;
    --muted:#B8BDC7;
    --accent:#D4AF37; /* gold only for rims */
    --node-border: rgba(212,175,55,.28);
    --panel-border: rgba(212,175,55,.22);
    --shadow-1: 0 2px 4px rgba(0,0,0,.35);
    --shadow-2: 0 12px 28px rgba(0,0,0,.55);
    --shadow-3: 0 40px 80px rgba(0,0,0,.65);
    /* reset previous goldy wiring */
    --handle-bg: rgba(255,255,255,.06);
    --handle-border: rgba(255,255,255,.22);
    --handle-bg-strong: rgba(255,255,255,.12);
    --handle-icon: rgba(255,255,255,.9);
    --wire-stroke: rgba(255,255,255,.12);
    --wire-shadow: rgba(0,0,0,.65);
    --connect-hover-outline: #7a7a7a;
  }

  /* Pure black canvas w/ subtle vignette + grain; remove gold aurora */
  html:not(.light) body {
    background-image:
      radial-gradient(1200px 600px at 30% -10%, rgba(255,255,255,.06), transparent 60%),
      radial-gradient(1600px 900px at 80% -20%, rgba(255,255,255,.04), transparent 65%),
      url("data:image/svg+xml;utf8,%3Csvg xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg' width%3D'128' height%3D'128'%3E%0A%3Cfilter id%3D'n'%3E%3CfeTurbulence type%3D'fractalNoise' baseFrequency%3D'0.9' numOctaves%3D'1' stitchTiles%3D'stitch'%2F%3E%3C%2Ffilter%3E%0A%3Crect width%3D'100%' height%3D'100%' filter%3D'url(%23n)' opacity%3D'.035'%2F%3E%0A%3C%2Fsvg%3E"),
      linear-gradient(180deg, #0b0b0d, #0a0a0b);
    background-blend-mode: normal, normal, overlay, normal;
  }

  /* Topbar and navigation: black glass with realistic shadow */
  html:not(.light) .topbar {
    background: rgba(14,14,16,.85);
    backdrop-filter: blur(6px);
    border-bottom: 1px solid var(--panel-border);
    box-shadow: var(--shadow-1), var(--shadow-2);
  }

  /* Panels / sidebars / docks — gold rim only */
  html:not(.light) .panel,
  html:not(.light) .sidebar,
  html:not(.light) .dock,
  html:not(.light) .inspector {
    background: var(--panel);
    color: var(--text);
    border: 1px solid var(--panel-border);
    box-shadow: var(--shadow-1), var(--shadow-2), var(--shadow-3);
  }

  /* Nodes — black glass with gold rim */
  html:not(.light) .node,
  html:not(.light) .group,
  html:not(.light) .textbox {
    background: rgba(20,21,24,.88);
    border: 1px solid var(--node-border);
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.03),
      var(--shadow-1), var(--shadow-2);
  }
  html:not(.light) .node:hover,
  html:not(.light) .group:hover,
  html:not(.light) .textbox:hover {
    border-color: rgba(212,175,55,.40);
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.05),
      0 4px 8px rgba(0,0,0,.35),
      0 18px 40px rgba(0,0,0,.6);
  }
  html:not(.light) .textbox.selected,
  html:not(.light) .node.selected,
  html:not(.light) .group.selected {
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.05),
      0 0 0 1px rgba(212,175,55,.55),
      0 24px 60px rgba(0,0,0,.65);
  }

  /* Menus: neutral; keep gold on rim only */
  html:not(.light) .menu {
    background: rgba(18,18,20,.96);
    border: 1px solid var(--panel-border);
    box-shadow: var(--shadow-1), var(--shadow-2);
  }
  html:not(.light) .menu button:hover {
    background: rgba(255,255,255,.06);
  }
  html:not(.light) .menu hr { border-top-color: rgba(255,255,255,.08); }

  /* Buttons, inputs — neutral greys */
  html:not(.light) button,
  html:not(.light) select,
  html:not(.light) input[type="text"],
  html:not(.light) input[type="search"] {
    background: rgba(24,24,26,.9);
    color: var(--text);
    border: 1px solid rgba(255,255,255,.10);
    box-shadow: var(--shadow-1);
  }
  html:not(.light) button:hover {
    border-color: rgba(255,255,255,.18);
  }

  /* Handles / wires — grayscale */
  html:not(.light) .handle {
    background: var(--handle-bg);
    border: 1px solid var(--handle-border);
  }
  html:not(.light) .wire {
    stroke: var(--wire-stroke);
    filter: drop-shadow(0 2px 2px var(--wire-shadow));
  }

  /* Contextual overlays */
  html:not(.light) .drop-overlay {
    background: rgba(255,255,255,.06);
    border: 1px dashed rgba(255,255,255,.22);
  }
  html:not(.light) .drop-message { border-color: rgba(255,255,255,.22); }

  /* Spotlight */
  html:not(.light) #spotlightOverlay { background: rgba(0,0,0,.55); }
  html:not(.light) .spotlight-card {
    background: rgba(16,16,18,.96);
    border: 1px solid var(--panel-border);
    box-shadow: var(--shadow-1), var(--shadow-2);
  }
  html:not(.light) .spotlight-input {
    border: 1px solid rgba(255,255,255,.15);
    background: rgba(255,255,255,.05);
    color: var(--text);
  }
</style>

<style id="checklist-select-fix">


  /* Make checklist selection visible in both themes */
  .checknode.selected{
    outline: 2px solid var(--accent);
    outline-offset: 2px;
    border-color: var(--node-border);
  }

/* Saved boards — thumbnail cards (PNG preview + actions) */
#saveList{ display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:10px; }
.save-card{
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.08);
  border-radius:12px; padding:10px; display:grid; gap:8px;
}
.save-card img{ width:100%; height:96px; object-fit:cover; border-radius:8px; background:#000; }
.save-card .meta{ font-size:12px; opacity:.9; line-height:1.2; display:grid; gap:2px; }
.save-card .row{ display:flex; gap:6px; }
.save-card button{ flex:1; padding:6px 8px; font-size:12px; border-radius:8px; cursor:pointer; }
</style>

<style id="no-sheen-patch">
/* Disable sheen & micro shimmer on textboxes to prevent stutter */
.textbox::before,
.textbox::after{
  background: none !important;
  animation: none !important;
  mix-blend-mode: normal !important;
  filter: none !important;
  will-change: auto !important;
  opacity: 1 !important;
}
</style>

<style id="tb-ctx-css">
/* Textbox color context menu */
#tbCtxMenu{
  position: fixed; z-index: 99999; width: 220px;
  background: rgba(22,26,43,.98);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 12px; padding: 10px;
  box-shadow: 0 12px 32px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06);
  display: none;
  backdrop-filter: blur(8px);
}
#tbCtxMenu .title{ font-size:12px; color:#cfd7ff; opacity:.9; margin-bottom:8px; }
#tbCtxMenu .row{ display:flex; gap:8px; align-items:center; margin:6px 0; }
#tbCtxMenu input[type="color"]{ width: 100%; height: 36px; padding:0; border:0; background:transparent; cursor:pointer; }
#tbCtxMenu .seg{
  display:grid; grid-auto-flow:column; gap:6px;
}
#tbCtxMenu .seg button{
  flex:1; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06); color:#e8ecff; cursor:pointer; font-size:12px;
}
#tbCtxMenu .seg button.active{ outline:2px solid rgba(139,92,246,.65); }
#tbCtxMenu .swatch{
  display:grid; grid-template-columns: repeat(6, 1fr); gap:6px;
}
#tbCtxMenu .swatch button{
  width: 24px; height: 24px; border-radius:6px; border:1px solid rgba(255,255,255,.18); cursor:pointer;
}
</style>

<style id="mobile-enhance-css">
/* Mobile-friendly panels */
@media (max-width: 900px){
  .url-panel, .save-panel{
    width: min(88vw, 520px) !important;
    max-height: calc(100vh - 140px) !important;
    font-size: 14px;
  }
  .save-panel h3, .url-panel h3{ font-size: 16px; }
  .save-panel button, .url-panel button{ font-size: 13px; }
}
@media (max-width: 600px){
  .url-panel, .save-panel{
    width: min(94vw, 460px) !important;
    max-height: calc(100vh - 120px) !important;
    font-size: 13px;
  }
  .save-panel h3, .url-panel h3{ font-size: 15px; }
  .save-panel button, .url-panel button{ font-size: 12px; padding: 8px 10px; }
}
/* Ensure the board captures touch gestures for dragging without scroll jitter */
#viewport{
  touch-action: none;
}
</style>

<style id="zoom-btn-css">
#zoomControls{
  display:flex; align-items:center; gap:8px;
  background: rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.12);
  padding:6px 10px; border-radius:12px;
  position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
  z-index:2000;
}
.zoom-btn{
  width:32px; height:32px; font-size:18px; font-weight:bold;
  border-radius:8px; border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.08);
  color:#e8ecff; cursor:pointer;
}
.zoom-btn:hover{ background: rgba(255,255,255,.15); }
#zoomPct{ min-width:50px; text-align:center; font-weight:600; color:#fff; }
</style>

<style id="zoom-steps-css">
/* Zoom controls replacing the old % panel */
.scale-bar{ gap:10px; }
#zoomControls{
  display:flex; align-items:center; gap:8px;
  background: rgba(0,0,0,.25);
  border:1px solid rgba(255,255,255,.1);
  padding:4px 6px; border-radius:10px;
  backdrop-filter: blur(6px);
}
#zoomMinus, #zoomPlus{
  width:32px; height:32px; border-radius:8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  font-size:18px; color:#e8ecff; cursor:pointer;
  display:grid; place-items:center;
}
#zoomMinus:active, #zoomPlus:active{ transform: translateY(1px); }
#zoomLabel{ min-width:60px; text-align:center; font-variant-numeric: tabular-nums; }
</style>

<style>
/* Minimalistic panel toggles */
.url-panel, .save-panel{
  position: relative;
}
.panel-toggle{
  position: absolute;
  top: 8px; right: 8px;
  width: 28px; height: 28px;
  border-radius: 8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  color: #e8ecff; cursor: pointer;
  display: grid; place-items: center;
  font-size: 16px; line-height: 1;
}
.panel-toggle:active{ transform: translateY(1px); }

/* When collapsed: hide inner content except the header */
.panel-collapsible .panel-body{ display: block; }
.panel-collapsible.collapsed .panel-body{ display: none; }

/* Make headers clickable targets too (optional) */
.panel-collapsible > h3{
  padding-right: 40px;  /* leave space for toggle button */
  position: relative;
}
</style>

<style id="alignment-and-zoom-pin-css">
/* Pin zoom to bottom-center, safe-area aware (static offset), override any previous rules */
.scale-bar{
  position: fixed !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
  bottom: calc(env(safe-area-inset-bottom, 0px) + 36px) !important;
  z-index: 2200 !important;
}

/* Panel alignment + clamping */
.url-panel, .save-panel{
  position: fixed;  /* make positions deterministic */
  left: 12px;
}
.url-panel{ top: 72px; }           /* header height buffer */
.save-panel{ top: auto; }          /* JS will place it under URL panel */
@media (max-width: 900px){
  .url-panel, .save-panel{ left: 12px; right: auto; }
}
</style>


<style id="save-panel-responsive-css">
/* Make Save & Load internals adapt to panel width */
.save-panel .save-buttons{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}
.save-panel .save-buttons button{
  flex: 1 1 auto;
  min-width: 120px;
}

/* Responsive list: single column on narrow panels, multi when wider */
.save-panel #saveList{
  display: grid;
  grid-template-columns: 1fr;
  gap: 10px;
  overflow-x: hidden;
}
@media (min-width: 720px){
  .save-panel #saveList{
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  }
}

/* Cards fill width and wrap neatly */
.save-panel .save-card{
  width: 100%;
  box-sizing: border-box;
}
.save-panel .save-card .meta{
  word-break: break-word;
  overflow-wrap: anywhere;
}

/* Thumbnails scale with width, maintain aspect ratio */
.save-panel .save-card img{
  display: block;
  width: 100%;
  height: auto !important;
  aspect-ratio: 16 / 9;
  object-fit: cover;
  border-radius: 8px;
  background: #000;
}

/* Action row wraps when tight */
.save-panel .save-card .row{
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.save-panel .save-card .row button{
  flex: 1 1 90px;
  min-width: 86px;
}
</style>

<style id="pointer-gestures-css">
#viewport, #board { touch-action: none; }
</style>
<style id="panel-collapse-to-button-css">
/* Collapse panels to small floating buttons */
.url-panel, .save-panel{ position: fixed; }
.url-panel.panel-collapsed, .save-panel.panel-collapsed{
  width: 44px !important;
  height: 44px !important;
  padding: 0 !important;
  overflow: hidden !important;
  display: grid !important;
  place-items: center !important;
  border-radius: 12px !important;
}
/* Hide body and header when collapsed */
.url-panel.panel-collapsed .panel-body,
.save-panel.panel-collapsed .panel-body,
.url-panel.panel-collapsed h3,
.save-panel.panel-collapsed h3{ display: none !important; }

/* Toggle button */
.panel-toggle{
  position: absolute; top: 8px; right: 8px;
  width: 28px; height: 28px; border-radius: 8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  color: #e8ecff; cursor: pointer; display: grid; place-items: center;
  font-size: 16px; line-height: 1;
}
.panel-toggle:active{ transform: translateY(1px); }

/* When collapsed, the toggle becomes the button face */
.url-panel.panel-collapsed .panel-toggle,
.save-panel.panel-collapsed .panel-toggle{
  position: static; width: 36px; height: 36px; margin: 0;
}

/* Positions (left for URL, right for Save) */
.url-panel{ top: 80px; left: 16px; }
.save-panel{ top: 80px; right: 16px; }
</style>

<style id="node-title-hit-css">
/* Larger, easier-to-tap node title */
.node .title{
  padding: 6px 10px !important;
  font-size: 14px !important;
  min-height: 28px;
  line-height: 1.2;
  touch-action: manipulation !important;   /* allow taps to trigger focus */
  -webkit-user-select: text !important;
  user-select: text !important;
}
/* Extra hit-slap area (invisible) for small titles */
.node .title::after{
  content:"";
  position:absolute;
  left:-6px; right:-6px; top:-6px; bottom:-6px;
  border-radius: 14px;
  pointer-events: none; /* purely enlarges the easy tap visual area; not blocking */
}
/* When editing, ensure text cursor and visual affordance */
.node .title.editing{
  cursor: text !important;
}
</style>


<style id="collapsed-panels-css">
/* Collapsed look: keep existing colors/background/borders from panel, just compress */
.url-panel.panel-collapsed,
.save-panel.panel-collapsed{
  width: 56px !important;
  height: 56px !important;
  min-width: 56px !important;
  min-height: 56px !important;
  padding: 0 !important;
  display: grid !important;
  place-items: center !important;
  border-radius: 12px;
  overflow: hidden !important;
}
/* Hide content except the toggle button (used as the face) */
.url-panel.panel-collapsed .panel-body,
.url-panel.panel-collapsed h3,
.save-panel.panel-collapsed .panel-body,
.save-panel.panel-collapsed h3{
  display: none !important;
}

/* The toggle becomes the face with centered label text */
.panel-toggle{
  position: absolute;
  top: 8px; right: 8px;
  width: 28px; height: 28px;
  border-radius: 8px;
  background: rgba(255,255,255,.08);
  border: 1px solid rgba(255,255,255,.14);
  color: inherit;
  cursor: pointer;
  display: grid;
  place-items: center;
  font-weight: 600;
}
/* In collapsed mode, the button fills and shows the label ("URL"/"Save") */
.url-panel.panel-collapsed .panel-toggle,
.save-panel.panel-collapsed .panel-toggle{
  position: static;
  width: 100%; height: 100%;
  margin: 0;
  background: transparent;
  border: none;
  color: inherit;
  font-size: 14px;
  letter-spacing: .2px;
}
</style>

</head>
<body>
  <header class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <div class="title">Blank Space</div>
        <div class="subtitle">Infinite node-based workflow board powered by GPT5</div>
      </div>
    </div>
    <div class="actions">
      <button id="btnUploadImage">Upload Image</button>
      <button id="btnUploadVideo">Upload Video</button>
      <button id="btnUploadPDF">Upload Document</button>
      <select id="theme">
        <option value="dark" selected>Dark</option>
        <option value="light">Light</option>
      </select>
    </div>
  </header>

  <!-- URL Import Panel -->
  <div class="url-panel">
    <h3>Import from URL</h3>
    <div class="url-types">
      Supports: YouTube (videos & Shorts), Instagram (posts & Reels), X/Twitter (posts), images (JPG, PNG, GIF, WEBP), video files (MP4, WEBM, OGG, HLS), and websites
    </div>
    <input type="text" id="urlInput" placeholder="Paste URL here..." />
    <div class="url-buttons">
      <button id="btnImportUrl">Import</button>
      <button id="btnClearUrl">Clear</button>
    </div>
  </div>

  <!-- Save/Load Panel -->
  <div class="save-panel">
    <h3>Save & Load</h3>
    <div class="save-buttons">
      <button id="btnSave">Save Board</button>
      <button id="btnExport">Export JSON</button>
      <button id="btnImport">Import JSON</button>
    </div>
    <div class="save-list" id="saveList"></div>
  </div>

  <div id="root">
    <div id="viewport">
      <div id="board" class="board grid" tabindex="0"></div>
    </div>
    <div class="scale-bar" id="zoomControls">
  <button type="button" class="zoom-btn" data-zoom-dir="-">−</button>
  <span id="zoomPct">100%</span>
  <button type="button" class="zoom-btn" data-zoom-dir="+">+</button>
</div></div>
    </div>
  </div>

  <!-- Hidden inputs for uploads -->
  <input id="fileImage" type="file" accept="image/*" multiple style="display:none"/>
  <input id="fileVideo" type="file" accept="video/*" multiple style="display:none"/>
  <input id="filePDF" type="file" accept="application/pdf" multiple style="display:none"/>
  <input id="fileImport" type="file" accept=".json" style="display:none"/>

  <!-- Google Maps Modal -->
  <div id="mapModal" class="modal-overlay" style="display:none;">
    <div class="map-modal">
      <h3>Add Google Map Route</h3>
      <div class="input-group">
        <label for="mapStart">Start Point:</label>
        <input type="text" id="mapStart" placeholder="Enter starting location..." />
      </div>
      <div class="input-group">
        <label for="mapDestination">Destination:</label>
        <input type="text" id="mapDestination" placeholder="Enter destination..." />
      </div>
      <div class="modal-buttons">
        <button id="mapCancel">Cancel</button>
        <button id="mapCreate" style="background: var(--accent);">Create Map</button>
      </div>
    </div>
  </div>

  <!-- Drop overlay for drag and drop -->
  <div id="dropOverlay" class="drop-overlay">
    <div class="drop-message">
      <h3>Drop files to add to board</h3>
      <p>Images, videos, and PDFs supported</p>
    </div>
  </div>

  <!-- Context menus -->
  <menu id="canvasMenu" class="menu">
    <button data-action="upload-image">Upload Image…</button>
    <button data-action="upload-video">Upload Video…</button>
    <button data-action="upload-pdf">Upload Document…</button>
    <hr/>
    <button data-action="add-google-map">Add Google Map</button>
    <hr/>
    <button data-action="create-group">Create Group</button>
    <button data-action="create-textbox">Create Text Box</button>
    <button data-action="add-checknode">➕ Add Checklist</button>
  </menu>

  <menu id="nodeMenu" class="menu">
    <button data-action="open">Open / Play</button>
    <hr/>
    <button data-action="toggle-metadata">Show metadata</button>
    <!-- INSERT THESE TWO LINES -->
    <button data-action="connect">Connect</button>
    <hr/>
    <!-- /INSERT -->
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>

  
  <menu id="groupMenu" class="menu">
    <button data-action="rename">Rename…</button>
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>
<menu id="textboxMenu" class="menu">
    <button data-action="connect">Connect</button>
    <hr/>
    <button data-action="duplicate">Duplicate</button>
    <hr/>
    <button data-action="color">Textbox color…</button>
    <hr/>
    <button data-action="delete" class="danger">Delete</button>
  </menu>

  <menu id="wireMenu" class="menu">
    <button data-action="disconnect" class="danger">Disconnect</button>
  </menu>

  <script>
    console.log('Script starting...');
    
    // v4.8 — Fixed textbox loading with proper state management
    const state = {
      zoom: 1,
      origin: {x: 0, y: 0},
      nodes: [],
      groups: [],
      textboxes: [],
      selection: new Set(),
      nextId: 1,
      isPanning: false,
      panStart: {x:0,y:0},
      originStart: {x:0,y:0}
    };

    const board = document.getElementById('board');
    board.addEventListener('click', (e)=>{ if(e.button===0 && typeof closeMenus==='function') closeMenus(); });
    const viewport = document.getElementById('viewport');
    const canvasMenu = document.getElementById('canvasMenu');
    const nodeMenu = document.getElementById('nodeMenu');
    const textboxMenu = document.getElementById('textboxMenu');
    const wireMenu = document.getElementById('wireMenu');

    console.log('Elements found:', {board, viewport, canvasMenu, nodeMenu, textboxMenu, wireMenu});

    function init(){
      console.log('Initializing...');
      resizeBoard();
      bindGlobal();
      bindUrlPanel();
      bindSavePanel();
      bindMapModal();
      setupDragAndDrop();
      createGroup({x:200, y:200});
      applyTransform();
      loadSavedBoards();
      console.log('Initialization complete');
    }

    function resizeBoard(){
      board.style.width = `50000px`;
      board.style.height = `50000px`;
    }

    function applyTransform(){
      board.style.transform = `translate(${state.origin.x}px, ${state.origin.y}px) scale(${state.zoom})`;
      document.getElementById('zoomPct').textContent = `${Math.round(state.zoom*100)}%`;
    }

    function bindGlobal(){
      console.log('Binding global events...');
      
      const themeSel = document.getElementById('theme');
      themeSel.addEventListener('change', ()=> {
        if(themeSel.value==='light') document.documentElement.classList.add('light');
        else document.documentElement.classList.remove('light');
      });

      // Upload triggers
      document.getElementById('btnUploadImage').addEventListener('click', ()=> {
        console.log('Upload image clicked');
        document.getElementById('fileImage').click();
      });
      document.getElementById('btnUploadVideo').addEventListener('click', ()=> {
        console.log('Upload video clicked');
        document.getElementById('fileVideo').click();
      });
      document.getElementById('btnUploadPDF').addEventListener('click', ()=> {
        console.log('Upload PDF clicked');
        document.getElementById('filePDF').click();
      });
      
      document.getElementById('fileImage').addEventListener('change', (e)=> handleFiles(e.target.files));
      document.getElementById('fileVideo').addEventListener('change', (e)=> handleFiles(e.target.files));
      document.getElementById('filePDF').addEventListener('change',  (e)=> handleFiles(e.target.files));

      // Wheel zoom
      viewport.addEventListener('wheel', (e)=>{
        // Prevent board zoom when scrolling inside text inputs/boxes
        const inTextbox = e.target.closest('.textbox');
        const isEditable = e.target.closest('[contenteditable="true"]');
        const isFormInput = e.target.closest('input, textarea');
        if (inTextbox || isEditable || isFormInput) {
          return; // let the element handle its own scrolling
        }
        e.preventDefault();

        const delta = -e.deltaY;
        const zoomFactor = Math.exp(delta*0.001);
        const prev = state.zoom;
        const next = Math.min(4, Math.max(0.2, prev*zoomFactor));
        if(next===prev) return;
        const rect = viewport.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const ox = (cx - state.origin.x) / prev;
        const oy = (cy - state.origin.y) / prev;
        state.origin.x = cx - ox*next;
        state.origin.y = cy - oy*next;
        state.zoom = next;
        applyTransform();
      }, {passive:false});

      // Left-drag on empty canvas pans OR deselects
      viewport.addEventListener('mousedown', (e)=>{
        if(e.button===0 && typeof closeMenus==='function') closeMenus();
        if(e.button === 1) { // Middle mouse button - pan only
          e.preventDefault();
          startPanning(e);
          return;
        }
        
        if(e.button!==0) return; // Only handle left mouse button for selection/pan
        if (e.target.closest('.textbox')) return;
        // Check if clicking on empty space (not on any node, group, or textbox)
        const clickedOnContent = e.target.closest('.node, .group, .textbox');
        
        if(!clickedOnContent) {
          // Clicking on empty space
          if(e.shiftKey) { 
            beginMarquee(e); 
            return; 
          }
          
          // Clear selection on empty space click
          clearSelection();
          
          // Only start panning if we're not just deselecting
          startPanning(e);
        }
    });
      
      // Handle middle mouse button wheel clicks for panning
      viewport.addEventListener('auxclick', (e) => {
        if(e.button === 1) { // Middle mouse button
          e.preventDefault();
          startPanning(e);
        }
      });

      // Context menus
      viewport.addEventListener('contextmenu', (e)=>{
        console.log('Context menu triggered');
        e.preventDefault();
        
        // Check for wire handle first (highest priority)
        const wireHandle = e.target.closest('.wire-handle');
        if(wireHandle) {
          console.log('Opening wire handle context menu');
          openWireMenu(e.clientX, e.clientY, wireHandle);
          return;
        }
        
        // Check for wire path or hit area
        const wirePath = e.target.closest('.wire-path, .wire-hit-area');
        if(wirePath) {
          console.log('Opening wire path context menu');
          openWireMenu(e.clientX, e.clientY, wirePath);
          return;
        }
        
        // Check for checklist node
        const checklistNode = e.target.closest('.checknode');
        if(checklistNode) {
          console.log('Opening checklist context menu');
          openChecklistMenu(e.clientX, e.clientY, checklistNode);
          return;
        }
        
        const textbox = e.target.closest('.textbox');
        if(textbox && !textbox.classList.contains('metadata')){
          console.log('Opening textbox menu');
          const textboxObj = getTextboxByElement(textbox);
          if(textboxObj) {
            openTextboxMenu(e.clientX, e.clientY, textboxObj);
            return;
          }
        }
        
        const targetNode = e.target.closest('.node');
        if(targetNode){
          console.log('Opening node menu');
          const id = targetNode.dataset.id;
          openNodeMenu(e.clientX, e.clientY, getNodeById(id));
        }else{
          console.log('Opening canvas menu');
          // Group menu when right-clicking empty group area
          const groupEl = e.target.closest('.group');
          if(groupEl && !e.target.closest('.node')){
            console.log('Opening group menu');
            const gid = groupEl.dataset.id; const g = (typeof getGroupById==='function') ? getGroupById(gid) : groupEl;
            openGroupMenu(e.clientX, e.clientY, g);
            return;
          }

          openCanvasMenu(e.clientX, e.clientY);
        }
      });

      // Delete key
      window.addEventListener('keydown', (e)=>{
        const active = document.activeElement;
        if(active && active.classList && active.classList.contains('textbox')) return;
        if(active && active.tagName === 'INPUT') return;
        if(e.key==='Delete' || e.key==='Backspace'){
          const ids = Array.from(state.selection);
          ids.forEach(id=>{
            const n = getNodeById(id); if(n) { n.el.remove(); state.nodes = state.nodes.filter(x=>x!==n); }
            const g = getGroupById(id); if(g) { g.el.remove(); state.groups = state.groups.filter(x=>x!==g); }
            const t = getTextboxById(id); if(t) { t.element.remove(); state.textboxes = state.textboxes.filter(x=>x!==t); }
            const el = getElement(id); if(el && el.classList && el.classList.contains('checknode')){ if(typeof deleteChecklistNode==='function') deleteChecklistNode(el);}
          });
          clearSelection();
        }
      });

      window.addEventListener('resize', applyTransform);
    }

    function startPanning(e) {
      state.isPanning = true;
      state.panStart = {x:e.clientX, y:e.clientY};
      state.originStart = {...state.origin};
      viewport.classList.add('dragging');
      
      function move(ev){
        if(!state.isPanning) return;
        state.origin.x = state.originStart.x + (ev.clientX - state.panStart.x);
        state.origin.y = state.originStart.y + (ev.clientY - state.panStart.y);
        applyTransform();
      }
      function up(){
        state.isPanning=false;
        viewport.classList.remove('dragging');
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', up);
      }
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', up);
    }

    function bindUrlPanel(){
      console.log('Binding URL panel...');
      const urlInput = document.getElementById('urlInput');
      const btnImport = document.getElementById('btnImportUrl');
      const btnClear = document.getElementById('btnClearUrl');

      btnImport.addEventListener('click', ()=>{
        console.log('Import button clicked');
        const url = urlInput.value.trim();
        if(url){
          importFromUrl(url);
          urlInput.value = '';
        } else {
          alert('Please enter a URL');
        }
      });

      btnClear.addEventListener('click', ()=>{
        console.log('Clear button clicked');
        urlInput.value = '';
      });
    }

    function bindSavePanel(){
      console.log('Binding save panel...');
      document.getElementById('btnSave').addEventListener('click', saveBoard);
      document.getElementById('btnExport').addEventListener('click', exportBoard);
      document.getElementById('btnImport').addEventListener('click', ()=> document.getElementById('fileImport').click());
      document.getElementById('fileImport').addEventListener('change', importBoard);
    }

    function bindMapModal(){
      console.log('Binding map modal...');
      const modal = document.getElementById('mapModal');
      const startInput = document.getElementById('mapStart');
      const destInput = document.getElementById('mapDestination');
      const cancelBtn = document.getElementById('mapCancel');
      const createBtn = document.getElementById('mapCreate');

      cancelBtn.addEventListener('click', closeMapModal);
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeMapModal();
      });

      createBtn.addEventListener('click', () => {
        const start = startInput.value.trim();
        const destination = destInput.value.trim();
        
        if (!start || !destination) {
          alert('Please enter both start point and destination');
          return;
        }
        
        createGoogleMapNode(start, destination);
        closeMapModal();
      });

      // Handle Enter key
      [startInput, destInput].forEach(input => {
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            if (input === startInput && !destInput.value.trim()) {
              destInput.focus();
            } else {
              createBtn.click();
            }
          }
          if (e.key === 'Escape') {
            closeMapModal();
          }
        });
      });
    }

    function setupDragAndDrop() {
      const dropOverlay = document.getElementById('dropOverlay');
      
      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        document.addEventListener(eventName, preventDefaults, false);
      });
      
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      // Highlight drop area
      
      // Robust anti-flicker DnD overlay logic
      let __dragCounter = 0;
      function __showOverlay(){ dropOverlay.classList.add('active'); }
      function __hideOverlay(){ dropOverlay.classList.remove('active'); __dragCounter = 0; }

      // Use capture phase to catch events consistently
      document.addEventListener('dragenter', function(e){
        // Only consider real drags (files or URLs/text)
        const types = (e.dataTransfer && e.dataTransfer.types) || [];
        if (types.length === 0) return;
        __dragCounter++;
        __showOverlay();
      }, true);

      document.addEventListener('dragover', function(e){
        // Required to allow drop
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
      }, true);

      document.addEventListener('dragleave', function(e){
        // Some browsers fire many dragleave events as you cross children.
        // Only hide when counter returns to zero.
        __dragCounter = Math.max(0, __dragCounter - 1);
        if (__dragCounter === 0) __hideOverlay();
      }, true);

      document.addEventListener('drop', function(e){
        __hideOverlay();
      }, true);

      // Safety: reset overlay if page visibility changes mid-drag
      document.addEventListener('visibilitychange', function(){
        if (document.hidden) __hideOverlay();
      });

      // Handle dropped files
      document.addEventListener('drop', handleDrop, false);
      
      function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        
        if (files.length > 0) {
          const rect = viewport.getBoundingClientRect();
          const dropPos = screenToWorld(e.clientX, e.clientY);
          handleFiles(files, dropPos);
        }
      }
    }

    function openMapModal() {
      console.log('Opening map modal...');
      const modal = document.getElementById('mapModal');
      const startInput = document.getElementById('mapStart');
      const destInput = document.getElementById('mapDestination');
      
      // Clear previous values
      startInput.value = '';
      destInput.value = '';
      
      modal.style.display = 'block';
      setTimeout(() => startInput.focus(), 100);
    }

    function closeMapModal() {
      console.log('Closing map modal...');
      document.getElementById('mapModal').style.display = 'none';
    }

    function createGoogleMapNode(start, destination) {
      console.log('Creating Google Map node:', { start, destination });
      
      const encodedStart = encodeURIComponent(start);
      const encodedDest = encodeURIComponent(destination);
      
      const workingMapUrl = `https://maps.google.com/maps?q=${encodedStart}+to+${encodedDest}&output=embed`;
      
      const rect = viewport.getBoundingClientRect();
      const pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      
      const size = { w: 560, h: 400 };
      const meta = {
        start: start,
        destination: destination,
        mapType: 'directions',
        embedUrl: workingMapUrl,
        fullUrl: `https://www.google.com/maps/dir/${encodedStart}/${encodedDest}`
      };
      
      return createNode('map', workingMapUrl, size, pos, meta);
    }

    function importFromUrl(url){
      console.log('Importing from URL:', url);
      
      const rect = viewport.getBoundingClientRect();
      const pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      
      // Detect URL type and handle accordingly
      const urlType = detectUrlType(url);
      
      switch(urlType) {
        case 'video-file':
          createVideoNode(url, pos, {kind:'file'});
          break;
        case 'video-hls':
          createVideoNode(url, pos, {kind:'hls'});
          break;
    
        case 'twitter':
          createTwitterNode(url, pos);
          break;

        case 'instagram':
          createInstagramNode(url, pos);
          break;

        case 'youtube':
        case 'youtube-shorts':
          const videoId = extractYouTubeId(url);
          if(videoId) {
            createYouTubeNode(videoId, pos, urlType === 'youtube-shorts');
          } else {
            alert('Invalid YouTube URL');
          }
          break;
          
        case 'image':
          createImageFromUrl(url, pos);
          break;
          
        case 'website':
          createWebsiteNode(url, pos);
          break;
          
        default:
          alert('Unsupported URL type. Please use YouTube, image URLs (JPG, PNG, GIF), or website URLs.');
      }
    }

    function detectUrlType(url) {
      
      // Direct video files
      if (/(?:\.mp4|\.webm|\.ogv|\.ogg|\.mov|\.m4v)(?:\?|#|$)/i.test(url)) return 'video-file';
      // HLS playlists
      if (/\.m3u8(?:\?|#|$)/i.test(url)) return 'video-hls';
      // Short NYT links -> website (likely not embeddable; we show a link card overlay)
      try{ const u=new URL(url); if(/(^|\.)nyti\.ms$/i.test(u.hostname)) return 'website'; }catch(_e){}
    // Data URLs for images (supports webp/jpg/png/gif/svg/bmp)
      if (/^data:image\/(?:png|jpe?g|gif|webp|svg\+xml|bmp)/i.test(url)) {
        return 'image';
      }

      
      
      // X (Twitter) posts
      if (/(?:^https?:\/\/)?(?:(?:www\.)?(?:x|twitter)\.com|mobile\.twitter\.com)\/[^\/]+\/status\/(\d+)/i.test(url)) {
        return 'twitter';
      }
    // Instagram posts & Reels (also supports windows.instagram.com)
      if (/(?:^https?:\/\/)?(?:www\.|m\.|windows\.)?instagram\.com\/(?:reel|reels|p|tv)\//i.test(url)) {
        return 'instagram';
      }
    // YouTube regular videos
      if(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)/i.test(url)) {
        return 'youtube';
      }
      
      // YouTube Shorts
      if(/youtube\.com\/shorts\//i.test(url)) {
        return 'youtube-shorts';
      }
      
      // Image URLs
      if(/\.(jpg|jpeg|png|gif|webp|svg|bmp)(\?.*)?$/i.test(url)) {
        return 'image';
      }
      
      // Website URLs (anything with http/https that's not above)
      if(/^https?:\/\//i.test(url)) {
        return 'website';
      }
      
      return 'unknown';
    }

    function extractYouTubeId(url){
      const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/v\/([^&\n?#]+)/,
        /youtube\.com\/shorts\/([^&\n?#]+)/
      ];
      for(const pattern of patterns){
        const match = url.match(pattern);
        if(match) return match[1];
      }
      return null;
    }

    function createYouTubeNode(videoId, at, isShorts = false){
      const embedUrl = `https://www.youtube.com/embed/${videoId}`;
      const size = isShorts ? {w: 315, h: 560} : {w: 560, h: 315};
      const meta = {
        videoId: videoId,
        platform: 'youtube',
        embedUrl: embedUrl,
        isShorts: isShorts
      };
      return createNode('youtube', embedUrl, size, at, meta);
    }

    function createImageFromUrl(url, at) {
      console.log('Creating image from URL:', url);
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      
      img.onload = function() {
        const naturalW = img.naturalWidth;
        const naturalH = img.naturalHeight;
        const size = calculateOptimalImageSize(naturalW, naturalH);
        
        const meta = {
          originalUrl: url,
          dimensions: {w: naturalW, h: naturalH},
          source: 'url'
        };
        
        createNode('image', url, size, at, meta);
      };
      
      img.onerror = function() {
        alert('Failed to load image from URL. The image may not be accessible or may have CORS restrictions.');
      };
      
      img.src = url;
    }

    function createWebsiteNode(url, at) {
      console.log('Creating website node:', url);
      
      if (!url.match(/^https?:\/\//i)) {
        url = 'https://' + url;
      }
      
      const size = { w: 800, h: 600 };
      const meta = {
        originalUrl: url,
        website: true,
        domain: extractDomain(url)
      };
      
      return createNode('website', url, size, at, meta);
    }

    function extractDomain(url) {
      try {
        return new URL(url).hostname;
      } catch (e) {
        return 'Unknown';
      }
    }

    // Fixed textbox creation with proper state management
    function createFloatingTextbox(at){
      console.log('Creating textbox at:', at);
      const id = 't'+(state.nextId++);
      const el = document.createElement('div');
      el.className = 'textbox';
      el.contentEditable = 'true';
      el.spellcheck = false;
      el.dataset.id = id;
      el.style.left = at.x + 'px';
      el.style.top = at.y + 'px';
      el.style.width = '280px';
      el.style.height = '160px';
      
      const textboxObj = {
        id: id,
        element: el,
        hasPlaceholder: true,
        isEditing: false
      };
      
      state.textboxes.push(textboxObj);
      
      // Set initial placeholder
      setPlaceholderText(textboxObj);
      setupTextboxEvents(textboxObj);

      board.appendChild(el);
      return textboxObj;
    }

    function setPlaceholderText(textboxObj) {
      const el = textboxObj.element;
      el.innerHTML = '<span style="color: var(--muted); opacity: 0.7;">Click to start typing...</span>';
      textboxObj.hasPlaceholder = true;
      textboxObj.isEditing = false;
    }

    function clearPlaceholderText(textboxObj) {
      if (textboxObj.hasPlaceholder) {
        textboxObj.element.innerHTML = '';
        textboxObj.hasPlaceholder = false;
      }
    }

    function setupTextboxEvents(textboxObj) {
      const el = textboxObj.element;
      
      el.addEventListener('focus', ()=>{
        clearPlaceholderText(textboxObj);
        textboxObj.isEditing = true;
        el.style.cursor = 'text';
      });
      
      el.addEventListener('blur', ()=>{
        const textContent = el.textContent || '';
        const htmlContent = el.innerHTML || '';
        
        if(textContent.trim() === '' || htmlContent.trim() === '') {
          setPlaceholderText(textboxObj);
        }
        textboxObj.isEditing = false;
        el.style.cursor = 'grab';
      });

      // Selection and dragging
      el.addEventListener('mousedown', (e)=>{
        // Let real links win first
        const link = e.target.closest('a[href]');
        if (link) {
          // Do NOT select or start drag; let the upcoming click handler decide.
          return; 
        }
        if(e.target.classList.contains('tb-resizer')) return;
        
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) {
          toggleSelect(textboxObj.id);
        } else {
          selectId(textboxObj.id);
        }
        
        const isClickToEdit = !textboxObj.isEditing && (textboxObj.hasPlaceholder || !el.contains(document.activeElement));
        
        if(isClickToEdit){
          setTimeout(() => {
            el.focus();
            clearPlaceholderText(textboxObj);
            textboxObj.isEditing = true;
          }, 10);
          return;
        }
        
        if(!textboxObj.isEditing) {
          startTextboxDrag(e, textboxObj);
        }
        
        e.stopPropagation();
      });

      // Add a dedicated click handler for links:
      el.addEventListener('click', (e)=>{
        const link = e.target.closest('a[href]');
        if (!link) return;
        // If editing, only open on Cmd/Ctrl-click (keeps normal clicks for caret placement)
        if (textboxObj.isEditing && !(e.metaKey || e.ctrlKey)) {
          return; // let the caret move
        }
        e.preventDefault(); // prevent contenteditable caret quirks
        const href = link.getAttribute('href');
        if (href) window.open(href, '_blank', 'noopener');
      });

      // Add resizer
      const rh = document.createElement('div'); 
      rh.className = 'tb-resizer'; 
      rh.title = 'Drag to resize';
      el.appendChild(rh);
      
      rh.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        
        const startX = e.clientX;
        const startY = e.clientY;
        const startWidth = el.offsetWidth;
        const startHeight = el.offsetHeight;
        
        function mousemove(ev){
          const dx = (ev.clientX - startX) / state.zoom;
          const dy = (ev.clientY - startY) / state.zoom;
          const newWidth = Math.max(200, startWidth + dx);
          const newHeight = Math.max(120, startHeight + dy);
          
          el.style.width = newWidth + 'px';
          el.style.height = newHeight + 'px';
        }
        
        function mouseup(){
          window.removeEventListener('mousemove', mousemove);
          window.removeEventListener('mouseup', mouseup);
        }
        
        window.addEventListener('mousemove', mousemove);
        window.addEventListener('mouseup', mouseup);
      });
    }

    function startTextboxDrag(e, textboxObj) {
      const el = textboxObj.element;
      const selectedTextboxes = Array.from(state.selection)
        .map(id => getTextboxById(id))
        .filter(t => t && t !== null);
      
      if(selectedTextboxes.length === 0) {
        selectedTextboxes.push(textboxObj);
      }
      
      const startX = e.clientX;
      const startY = e.clientY;
      const startPositions = {};
      
      selectedTextboxes.forEach(t => {
        startPositions[t.id] = {
          x: parseFloat(t.element.style.left),
          y: parseFloat(t.element.style.top)
        };
      });
      
      el.style.cursor = 'grabbing';
      
      function mousemove(ev){
        const dx = (ev.clientX - startX) / state.zoom;
        const dy = (ev.clientY - startY) / state.zoom;
        
        selectedTextboxes.forEach(t => {
          const start = startPositions[t.id];
          t.element.style.left = (start.x + dx) + 'px';
          t.element.style.top = (start.y + dy) + 'px';
        });
        // <— add this
        if (window.updateAllWires) window.updateAllWires();
      }
      
      function mouseup(){
        el.style.cursor = 'grab';
        window.removeEventListener('mousemove', mousemove);
        window.removeEventListener('mouseup', mouseup);
      }
      
      window.addEventListener('mousemove', mousemove);
      window.addEventListener('mouseup', mouseup);
    }

    // Menu functions
    let canvasContextPoint = {x:0,y:0};
    
    function openCanvasMenu(x,y){
      console.log('Opening canvas menu at', x, y);
      closeMenus();
      canvasMenu.style.left = x+'px'; 
      canvasMenu.style.top = y+'px';
      canvasMenu.classList.add('open');
      canvasContextPoint = screenToWorld(x,y);
      
      canvasMenu.onmousedown = (e)=>e.stopPropagation();
      canvasMenu.onclick = (e)=>{
        const act = e.target.dataset.action; 
        if(!act) return;
        console.log('Canvas menu action:', act);
        closeMenus();
        if(act==='upload-image') document.getElementById('fileImage').click();
        if(act==='upload-video') document.getElementById('fileVideo').click();
        if(act==='upload-pdf') document.getElementById('filePDF').click();
        if(act==='add-google-map') openMapModal();
        if(act==='create-group') createGroup(canvasContextPoint);
        if(act==='create-textbox') createFloatingTextbox(canvasContextPoint);
        if(act==='add-checknode') {
          // Create checklist node at context point
          if(typeof window.addChecklistNodeAt === 'function') {
            window.addChecklistNodeAt(canvasContextPoint.x, canvasContextPoint.y, 'New item', false);
          }
        }
      };
    }
    
    function openNodeMenu(x,y,node){
      console.log('Opening node menu at', x, y);
      closeMenus();
      nodeMenu.style.left = x+'px'; 
      nodeMenu.style.top = y+'px';
      nodeMenu.classList.add('open');
      
      const toggleBtn = nodeMenu.querySelector('button[data-action="toggle-metadata"]');
      if(node.kind==='image'){
        toggleBtn.style.display='block';
        toggleBtn.textContent = node.metaShown ? 'Close metadata' : 'Show metadata';
      }else{
        toggleBtn.style.display='none';
      }
      
      nodeMenu.onmousedown = (e)=>e.stopPropagation();
      nodeMenu.onclick = (e) => {

        const act = e.target.dataset.action; 
        if(!act) return;
        console.log('Node menu action:', act);
        closeMenus();
        if (act==='connect'){
          // Begin connection mode from this node's element
          if (typeof window.__startConnectFrom === 'function') {
            window.__startConnectFrom(node.el);
          }
          return;
        }
        if(act==='delete'){ deleteNode(node); }
        if(act==='duplicate'){ duplicateNode(node); }
        if(act==='toggle-metadata'){
          if(node.metaShown){
            if(node.metaTextbox){ node.metaTextbox.remove(); node.metaTextbox = null; }
            node.metaShown=false;
          }else{
            node.metaTextbox = createMetadataTextbox(node);
            node.metaShown=true;
          }
        }
        if(act==='open'){
          if(node.kind==='image') window.open(node.assetUrl, '_blank');
          else if(node.kind==='video'){ const v = node.el.querySelector('video'); v && v.play(); }
          else if(node.kind==='pdf') window.open(node.assetUrl, '_blank');
          else if(node.kind==='youtube') window.open(`https://www.youtube.com/watch?v=${node.meta.videoId}`, '_blank');
          else if(node.kind==='map') {
            const fullUrl = node.meta.fullUrl || `https://www.google.com/maps/dir/${encodeURIComponent(node.meta.start || '')}/${encodeURIComponent(node.meta.destination || '')}`;
            window.open(fullUrl, '_blank');
          }
          else if(node.kind==='website') {
            const originalUrl = node.meta.originalUrl || node.assetUrl;
            window.open(originalUrl, '_blank');
          }
        }

};
    }

    function openTextboxMenu(x, y, textboxObj){
      console.log('Opening textbox menu at', x, y);
      closeMenus();
      textboxMenu.style.left = x + 'px';
      textboxMenu.style.top = y + 'px';
      textboxMenu.classList.add('open');
      
      textboxMenu.onmousedown = (e) => e.stopPropagation();
      textboxMenu.onclick = (e) => {
        const act = e.target.dataset.action;
        const menuX = x; const menuY = y;
        if(!act) return;
        console.log('Textbox menu action:', act);
        closeMenus();
        if (act === 'color') {
          e.stopPropagation();
          window.__openingTextboxColor = true;
          // Close existing menus first
          // (textbox menu will close, then we open color in next tick)
          if (typeof closeMenus==='function') closeMenus();
          setTimeout(()=>{
            if (typeof window.openTextboxColorAt === 'function') { window.openTextboxColorAt(x + 12, y + 8, textboxObj.element || textboxObj); }
            window.__openingTextboxColor = false;
          }, 0);
        } else if (act === 'connect') {
          if (typeof window.__startConnectFrom === 'function') {
            window.__startConnectFrom(textboxObj.element);
          }
          return;
        }
        if(act === 'delete') {
          removeTextbox(textboxObj);
        }
        if(act === 'duplicate') {
          duplicateTextbox(textboxObj);
        }
      };
    }
    
    function openWireMenu(x, y, wireElement){
      console.log('Opening wire menu at', x, y);
      closeMenus();
      wireMenu.style.left = x + 'px';
      wireMenu.style.top = y + 'px';
      wireMenu.classList.add('open');
      
      wireMenu.onmousedown = (e) => e.stopPropagation();
      wireMenu.onclick = (e) => {
        const act = e.target.dataset.action;
        if(!act) return;
        console.log('Wire menu action:', act);
        closeMenus();
        
        if(act === 'disconnect') {
          // Find the wire to disconnect
          disconnectWire(wireElement);
        }
      };
    }
    
    function disconnectWire(wireElement) {
      console.log('Disconnecting wire:', wireElement);
      
      // Strategy 1: Look for wire group with data-wire-id
      const wireGroup = wireElement.closest('g[data-wire-id]');
      if(wireGroup) {
        const wireId = wireGroup.dataset.wireId;
        console.log('Found wire group with ID:', wireId);
        wireGroup.remove();
        
        // Call wire management functions if available
        if(window.removeWireById && typeof window.removeWireById === 'function') {
          window.removeWireById(wireId);
        }
        if(window.updateAllWires && typeof window.updateAllWires === 'function') {
          window.updateAllWires();
        }
        console.log('Wire disconnected successfully');
        return;
      }
      
      // Strategy 2: Look for any parent group containing wire elements
      let wireContainer = wireElement.closest('g');
      while(wireContainer) {
        // Check if this group contains wire-related elements
        const hasWirePath = wireContainer.querySelector('.wire-path, .wire-hit-area');
        const hasWireHandle = wireContainer.querySelector('.wire-handle');
        
        if(hasWirePath || hasWireHandle) {
          console.log('Found wire container group, removing:', wireContainer);
          wireContainer.remove();
          
          // Call update functions
          if(window.updateAllWires && typeof window.updateAllWires === 'function') {
            window.updateAllWires();
          }
          console.log('Wire disconnected via container group');
          return;
        }
        
        // Move up to parent group
        wireContainer = wireContainer.parentElement?.closest('g');
      }
      
      // Strategy 3: Remove the immediate parent group
      const immediateGroup = wireElement.closest('g');
      if(immediateGroup) {
        console.log('Removing immediate parent group as fallback');
        immediateGroup.remove();
        
        if(window.updateAllWires && typeof window.updateAllWires === 'function') {
          window.updateAllWires();
        }
        console.log('Wire disconnected via immediate group fallback');
        return;
      }
      
      // Strategy 4: Try to remove the wire element itself
      if(wireElement.classList.contains('wire-path') || wireElement.classList.contains('wire-hit-area')) {
        console.log('Removing wire element directly');
        wireElement.remove();
        
        if(window.updateAllWires && typeof window.updateAllWires === 'function') {
          window.updateAllWires();
        }
        console.log('Wire element removed directly');
        return;
      }
      
      console.warn('Could not find a suitable wire element to remove');
    }
    
    function openChecklistMenu(x, y, checklistElement){
      console.log('Opening checklist menu at', x, y);
      closeMenus();
      textboxMenu.style.left = x + 'px';
      textboxMenu.style.top = y + 'px';
      textboxMenu.classList.add('open');
      
      textboxMenu.onmousedown = (e) => e.stopPropagation();
      textboxMenu.onclick = (e) => {
        const act = e.target.dataset.action;
        if(!act) return;
        console.log('Checklist menu action:', act);
        closeMenus();
        if (act === 'connect') {
          if (typeof window.__startConnectFrom === 'function') {
            window.__startConnectFrom(checklistElement);
          }
          return;
        }
        if(act === 'delete') {
          deleteChecklistNode(checklistElement);
        }
        if(act === 'duplicate') {
          duplicateChecklistNode(checklistElement);
        }
      };
    }
    
    function closeMenus(){ 
      canvasMenu.classList.remove('open'); 
      nodeMenu.classList.remove('open'); 
      textboxMenu.classList.remove('open'); 
      wireMenu.classList.remove('open'); 
      const groupMenu = document.getElementById('groupMenu'); if(groupMenu) groupMenu.classList.remove('open'); 
    }

    function removeTextbox(textboxObj) {
      textboxObj.element.remove();
      state.textboxes = state.textboxes.filter(t => t !== textboxObj);
      state.selection.delete(textboxObj.id);
    }

    function duplicateTextbox(textboxObj) {
      const originalEl = textboxObj.element;
      const newPos = {
        x: parseFloat(originalEl.style.left) + 20,
        y: parseFloat(originalEl.style.top) + 20
      };
      
      const newTextbox = createFloatingTextbox(newPos);
      newTextbox.element.style.width = originalEl.style.width;
      newTextbox.element.style.height = originalEl.style.height;
      
      // Copy content properly, handling placeholder text
      if (!textboxObj.hasPlaceholder) {
        newTextbox.element.innerHTML = originalEl.innerHTML;
        newTextbox.hasPlaceholder = false;
      }
      newTextbox.element.blur();
      
      return newTextbox;
    }
    
    function deleteChecklistNode(checklistElement) {
      const checklistId = checklistElement.dataset.id;
      
      // Remove from DOM
      checklistElement.remove();
      
      // Remove from tracking array
      if(window.checklistNodes) {
        const index = window.checklistNodes.findIndex(c => c.id === checklistId);
        if(index !== -1) {
          window.checklistNodes.splice(index, 1);
        }
      }
    }
    
    function duplicateChecklistNode(checklistElement) {
      const checklistId = checklistElement.dataset.id;
      
      // Find the checklist data
      const checklistData = window.checklistNodes ? window.checklistNodes.find(c => c.id === checklistId) : null;
      
      if(checklistData && window.addChecklistNodeAt) {
        // Create duplicate at offset position
        const newX = checklistData.x + 20;
        const newY = checklistData.y + 20;
        window.addChecklistNodeAt(newX, newY, checklistData.text, checklistData.checked);
      }
    }

    // Node creation
    function createNode(kind, assetUrl, size, at, extraMeta){
      const id = 'n'+(state.nextId++);
      const node = { 
        id, kind, x: at.x, y: at.y, w: size.w, h: size.h, assetUrl, textboxes:[], 
        meta: extraMeta||{}, metaShown:false, metaTextbox: null,
        title: generateNodeTitle(kind, extraMeta)
      };
      state.nodes.push(node);

      const el = document.createElement('div');
      el.className = `node ${kind}`;
      el.dataset.id = id;
      el.style.left = node.x+'px'; el.style.top = node.y+'px';
      el.style.width = node.w+'px'; el.style.height = node.h+'px';

      const title = document.createElement('div'); 
      title.className='title'; 
      title.textContent = node.title; 
      el.appendChild(title);

      const content = document.createElement('div'); 
      content.className='content'; 
      content.setAttribute('draggable','false'); 
      el.appendChild(content);
      
      if(kind==='image'){ 
        const img = document.createElement('img'); 
        img.src = assetUrl; 
        img.draggable=false; 
        content.appendChild(img); 
      }
      else if(kind==='video'){ 
        const vid = document.createElement('video'); 
        vid.src = assetUrl; 
        vid.controls = true; 
        vid.draggable=false; 
        content.appendChild(vid); 
      }
      else if(kind==='pdf'){ 
        const emb = document.createElement('embed'); 
        emb.src = assetUrl; 
        emb.type='application/pdf'; 
        emb.draggable=false; 
        content.appendChild(emb); 
      }
      else if(kind==='youtube'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        content.appendChild(iframe);
      }
      else if(kind==='map'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        iframe.draggable = false;
        iframe.loading = 'lazy';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        content.appendChild(iframe);
      }
      else if(kind==='website'){
        const iframe = document.createElement('iframe');
        iframe.src = assetUrl;
        iframe.frameBorder = '0';
        iframe.allowFullscreen = true;
        iframe.allow = (iframe.allow || '') + '; autoplay; encrypted-media; clipboard-write; picture-in-picture; web-share; fullscreen';
        iframe.allow = (iframe.allow || '') + '; autoplay; encrypted-media; clipboard-write; picture-in-picture; web-share; fullscreen';
        iframe.draggable = false;
        iframe.loading = 'lazy';
        iframe.referrerPolicy = 'no-referrer-when-downgrade';
        if (!/instagram\.com\/.*\/embed\/?/i.test(assetUrl)) {
        if (!/instagram\.com\/.*\/embed\/?/i.test(assetUrl)) { iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox'; }
      }
        content.appendChild(iframe);
      }

      
      
      else if(kind==='video'){
        const wrapper = document.createElement('div');
        wrapper.className = 'video-host';
        wrapper.style.width='100%';
        wrapper.style.height='100%';
        wrapper.style.display='flex';
        wrapper.style.alignItems='center';
        wrapper.style.justifyContent='center';
        wrapper.style.background='#000';

        const video = document.createElement('video');
        video.controls = true;
        video.playsInline = true;
        video.style.width='100%';
        video.style.height='100%';
        video.style.objectFit='contain';
        wrapper.appendChild(video);
        content.appendChild(wrapper);

        const src = assetUrl;
        if (node.meta && node.meta.type === 'hls'){
          ensureHlsJs().then((Hls)=>{
            try{
              if (Hls && Hls.isSupported()){
                const hls = new Hls();
                hls.loadSource(src);
                hls.attachMedia(video);
              } else if (video.canPlayType('application/vnd.apple.mpegURL')){
                video.src = src;
              } else {
                video.outerHTML = '<div style="color:#fff;padding:12px;">HLS not supported in this browser.</div>';
              }
            }catch(err){
              console.warn('HLS init failed', err);
              video.outerHTML = '<div style="color:#fff;padding:12px;">HLS failed to initialize.</div>';
            }
          });
        } else {
          video.src = src;
        }
      }
else if(kind==='twitter'){
        const host = document.createElement('div');
        host.className = 'tweet-host';
        host.style.width='100%';
        host.style.height='100%';
        host.style.overflow='auto';
        content.appendChild(host);
        ensureTwitterWidgets().then(function(tw){
          if (tw && tw.widgets && node.meta && node.meta.tweetId){
            tw.widgets.createTweet(node.meta.tweetId, host, { align: 'center' });
          }
        }).catch(console.warn);
      }
const toolbar = document.createElement('div'); 
      toolbar.className='toolbar';
      
      if(kind==='image'){
        const metaBtn = document.createElement('button'); 
        metaBtn.textContent='Show metadata';
        metaBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          if(node.metaShown){
            if(node.metaTextbox){ node.metaTextbox.remove(); node.metaTextbox = null; }
            node.metaShown = false; 
            metaBtn.textContent='Show metadata';
          }else{
            const box = createMetadataTextbox(node);
            node.metaTextbox = box;
            node.metaShown = true; 
            metaBtn.textContent='Close metadata';
          }
        });
        toolbar.appendChild(metaBtn);
      }
      el.appendChild(toolbar);

      setupTitleRename(title, node);

      if(kind==='image' || kind==='youtube' || kind==='pdf' || kind==='map' || kind==='website' || kind==='twitter'){
        const res = document.createElement('div'); 
        res.title="Resize";
        res.style.position='absolute'; res.style.width='12px'; res.style.height='12px';
        res.style.right='-6px'; res.style.bottom='-6px'; res.style.background='var(--handle-bg)';
        res.style.border='2px solid var(--handle-border)'; res.style.borderRadius='50%'; 
        res.style.cursor='nwse-resize'; res.style.zIndex='3';
        el.appendChild(res);
        
        res.addEventListener('mousedown', (e)=>{
          e.stopPropagation();
          const start = {x:e.clientX, y:e.clientY, w:node.w, h:node.h};
          function mm(ev){
                        const dx = (ev.clientX-start.x)/state.zoom;
            const dy = (ev.clientY-start.y)/state.zoom;
            node.w = Math.max(160, start.w + dx);
            node.h = Math.max(120, start.h + dy);
            el.style.width = node.w+'px'; 
            el.style.height = node.h+'px';
            if(node.metaTextbox){
              node.metaTextbox.style.left = (node.w + 16) + 'px';
            }
}
          function up(){ 
            window.removeEventListener('mousemove', mm); 
            window.removeEventListener('mouseup', up); 
          }
          window.addEventListener('mousemove', mm); 
          window.addEventListener('mouseup', up);
        });
      }

      board.appendChild(el);
      node.el = el;
      enableNodeInteractions(node);
      return node;
    }

    function setupTitleRename(titleEl, item) {
      let isRenaming = false;
      
      titleEl.addEventListener('click', (e)=>{
        e.stopPropagation();
        startRename();
      });
      
      function startRename(){
        if(isRenaming) return;
        isRenaming = true;
        
        const originalText = titleEl.textContent;
        titleEl.classList.add('editing');
        titleEl.contentEditable = true;
        titleEl.focus();
        
        const range = document.createRange();
        range.selectNodeContents(titleEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        
        function finishRename(){
          isRenaming = false;
          titleEl.contentEditable = false;
          titleEl.classList.remove('editing');
          
          const newText = titleEl.textContent.trim();
          if(newText && newText !== originalText){
            item.title = newText;
          } else {
            titleEl.textContent = originalText;
          }
        }
        
        function handleClickOutside(e) {
          if (!titleEl.contains(e.target)) {
            finishRename();
            document.removeEventListener('click', handleClickOutside);
          }
        }
        
        titleEl.addEventListener('blur', finishRename, {once: true});
        titleEl.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            titleEl.blur();
          }
          if(e.key === 'Escape'){
            titleEl.textContent = originalText;
            titleEl.blur();
          }
          e.stopPropagation();
        });
        
        setTimeout(() => {
          document.addEventListener('click', handleClickOutside);
        }, 10);
      }
    }

    function generateNodeTitle(kind, meta) {
      
      
      if (meta && meta.platform === 'twitter') {
        return 'X (Twitter) Post';
      }
    if (meta && meta.platform === 'instagram') {
        if (meta.type === 'p') return 'Instagram Post';
        if (meta.type === 'tv') return 'Instagram TV';
        return 'Instagram Reel';
      }
    if(kind === 'youtube' && meta && meta.videoId) {
        return meta.isShorts ? 'YouTube Shorts' : 'YouTube Video';
      }
      if(kind === 'map' && meta && meta.start && meta.destination) {
        const shortStart = meta.start.length > 15 ? meta.start.substring(0, 12) + "..." : meta.start;
        const shortDest = meta.destination.length > 15 ? meta.destination.substring(0, 12) + "..." : meta.destination;
        return `${shortStart} → ${shortDest}`;
      }
      if(kind === 'website' && meta && meta.domain) {
        return meta.domain.length > 25 ? meta.domain.substring(0, 22) + "..." : meta.domain;
      }
      if(meta && meta.file && meta.file.name) {
        let name = meta.file.name.replace(/\.[^/.]+$/, "");
        return name.length > 25 ? name.substring(0, 22) + "..." : name;
      }
      
      const kindNames = {
        image: 'Image',
        video: 'Video', 
        pdf: 'Document',
        youtube: 'YouTube Video',
        map: 'Google Map',
        website: 'Website'
      };
      
      return kindNames[kind] || 'Media';
    }

    function createMetadataTextbox(node){
      const meta = node.meta || {};
      const file = meta.file || {};
      const exif = meta.exif || null;
      const wrap = document.createElement('div');
      wrap.className='textbox metadata';
      wrap.contentEditable='false';
      wrap.style.left = (node.w + 16) + 'px';
      wrap.style.top = '0px';

      const kv = (k,v)=> `<div>${k}</div><div>${v ?? '-'}</div>`;
      const fileInfo = `
        <div class="section-title">File info</div>
        <div class="kv">
          ${kv('Name', file.name || '-')}
          ${kv('Type', file.type || '-')}
          ${kv('Size', formatSize(file.size))}
          ${kv('Dimensions', meta.dimensions ? meta.dimensions.w+'×'+meta.dimensions.h : '-')}
        </div>
      `;
      let exifInfo = `<div class="section-title">EXIF info</div>`;
      if(exif){
        exifInfo += `<div class="kv">
          ${kv('Camera', [exif.Make, exif.Model].filter(Boolean).join(' ') || '-')}
          ${kv('Lens', exif.LensModel || '-')}
          ${kv('Focal', exif.FocalLength ? exif.FocalLength+'mm' : '-')}
          ${kv('Exposure', exif.ExposureTime ? exif.ExposureTime+'s' : '-')}
          ${kv('Aperture', exif.FNumber ? 'f/'+exif.FNumber : '-')}
          ${kv('ISO', exif.ISO || '-')}
          ${kv('Taken', exif.DateTimeOriginal || '-')}
        </div>`;
      }else{
        exifInfo += `<div class="kv"><div>EXIF</div><div>No EXIF data found</div></div>`;
      }
      wrap.innerHTML = fileInfo + exifInfo;

      const rh = document.createElement('div'); 
      rh.className='tb-resizer'; 
      wrap.appendChild(rh);
      rh.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        const start = {x:e.clientX, y:e.clientY, w:wrap.offsetWidth, h:wrap.offsetHeight};
        function mm(ev){
          const dx = (ev.clientX-start.x)/state.zoom;
          const dy = (ev.clientY-start.y)/state.zoom;
          const w = Math.max(240, start.w + dx), h = Math.max(140, start.h + dy);
          wrap.style.width = w+'px'; wrap.style.height = h+'px';
        }
        function up(){ 
          window.removeEventListener('mousemove', mm); 
          window.removeEventListener('mouseup', up); 
        }
        window.addEventListener('mousemove', mm); 
        window.addEventListener('mouseup', up);
      });

      node.el.appendChild(wrap);
      return wrap;
    }

    function formatSize(bytes){
      if(!bytes && bytes!==0) return '-';
      const kb = bytes/1024, mb = kb/1024;
      return mb>=1 ? mb.toFixed(2)+' MB' : kb.toFixed(1)+' KB';
    }

    function createGroup(at){
      const id = 'g'+(state.nextId++);
      const g = { id, x: at.x, y: at.y, w: 420, h: 280, color:'#3b82f6', title:'Group '+id };
      state.groups.push(g);
      const el = document.createElement('div'); 
      el.className='group'; 
      el.dataset.id=id;
      el.style.left=g.x+'px'; 
      el.style.top=g.y+'px'; 
      el.style.width=g.w+'px'; 
      el.style.height=g.h+'px';
      el.style.borderColor = g.color;
      const title = document.createElement('div'); 
      title.className='title'; 
      title.textContent=g.title; 
      el.appendChild(title);
      const res = document.createElement('div'); 
      res.className='resizer'; 
      el.appendChild(res);
      
      setupTitleRename(title, g);
      
      board.appendChild(el);
      g.el = el;
      enableGroupInteractions(g);
      return g;
    }

    function enableNodeInteractions(node){
      const el = node.el;
      el.addEventListener('mousedown', (e)=>{
        if(e.button!==0) return;
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) toggleSelect(node.id); else selectId(node.id);
        startDragSelection(e);
        e.stopPropagation();
      });
    }

    function enableGroupInteractions(g){
      const el = g.el;
      el.addEventListener('mousedown', (e)=>{
        if(e.button!==0) return;
        const additive = e.shiftKey || e.metaKey || e.ctrlKey;
        if(additive) toggleSelect(g.id); else selectId(g.id);
        startDragSelection(e);
        e.stopPropagation();
      });
      
      const res = el.querySelector('.resizer');
      res.addEventListener('mousedown', (e)=>{
        e.stopPropagation();
        const start = {x:e.clientX, y:e.clientY, w:g.w, h:g.h};
        function mm(ev){
          const dx = (ev.clientX-start.x)/state.zoom;
          const dy = (ev.clientY-start.y)/state.zoom;
          g.w = Math.max(200, start.w + dx); 
          g.h = Math.max(160, start.h + dy);
          el.style.width = g.w+'px'; 
          el.style.height = g.h+'px';
        }
        function up(){ 
          window.removeEventListener('mousemove', mm); 
          window.removeEventListener('mouseup', up); 
        }
        window.addEventListener('mousemove', mm); 
        window.addEventListener('mouseup', up);
      });
    }

    function startDragSelection(e){
      const start = {x:e.clientX, y:e.clientY};
      const selected = Array.from(state.selection);
      const startRects = {};
      
      selected.forEach(sid=>{
        const n = getNodeById(sid); 
        const g = getGroupById(sid);
        const t = getTextboxById(sid);
        if(n) startRects[sid] = {x:n.x, y:n.y};
        if(g) startRects[sid] = {x:g.x, y:g.y};
        if(t) startRects[sid] = {x:parseFloat(t.element.style.left), y:parseFloat(t.element.style.top)};
      });
      
      function mm(ev){
        const dx = (ev.clientX-start.x)/state.zoom;
        const dy = (ev.clientY-start.y)/state.zoom;
        selected.forEach(sid=>{
          const n = getNodeById(sid); 
          const g = getGroupById(sid);
          const t = getTextboxById(sid);
          if(n){ 
            n.x = startRects[sid].x + dx; 
            n.y = startRects[sid].y + dy; 
            n.el.style.left = n.x+'px'; 
            n.el.style.top = n.y+'px'; 
          }
          if(g){ 
            g.x = startRects[sid].x + dx; 
            g.y = startRects[sid].y + dy; 
            g.el.style.left = g.x+'px'; 
            g.el.style.top = g.y+'px'; 
          }
          if(t){
            const newX = startRects[sid].x + dx;
            const newY = startRects[sid].y + dy;
            t.element.style.left = newX + 'px';
            t.element.style.top = newY + 'px';
          }
        });
        // <— add this
        if (window.updateAllWires) window.updateAllWires();
      }
      function up(){ 
        window.removeEventListener('mousemove', mm); 
        window.removeEventListener('mouseup', up); 
      }
      window.addEventListener('mousemove', mm); 
      window.addEventListener('mouseup', up);
    }

    function beginMarquee(e){
      clearSelection();
      const start = screenToWorld(e.clientX, e.clientY);
      const rectEl = document.createElement('div'); 
      rectEl.className='marquee'; 
      board.appendChild(rectEl);
      
      function mm(ev){
        const cur = screenToWorld(ev.clientX, ev.clientY);
        const x = Math.min(start.x, cur.x), y=Math.min(start.y, cur.y);
        const w = Math.abs(cur.x-start.x), h=Math.abs(cur.y-start.y);
        rectEl.style.left=x+'px'; rectEl.style.top=y+'px'; 
        rectEl.style.width=w+'px'; rectEl.style.height=h+'px';
        clearSelection();
        let anyNode=false;
        state.nodes.forEach(n=>{ 
          if(intersects({x,y,w,h}, n)){ selectId(n.id, true); anyNode=true; } 
        });
        if(window.checklistNodes){ window.checklistNodes.forEach(c=>{ const cw=c.element?c.element.offsetWidth:0; const ch=c.element?c.element.offsetHeight:0; if(intersects({x,y,w,h},{x:c.x,y:c.y,w:cw,h:ch})) { selectId(c.id, true); anyNode=true; } }); }
        if(!anyNode) {
          state.groups.forEach(g=>{ 
            if(intersects({x,y,w,h}, g)) selectId(g.id, true); 
          });
          state.textboxes.forEach(t=>{
            const tx = parseFloat(t.element.style.left);
            const ty = parseFloat(t.element.style.top);
            const tw = t.element.offsetWidth;
            const th = t.element.offsetHeight;
            if(intersects({x,y,w,h}, {x:tx,y:ty,w:tw,h:th})) selectId(t.id, true);
          });
        }
      }
      function up(){
        rectEl.remove();
        window.removeEventListener('mousemove', mm);
        window.removeEventListener('mouseup', up);
      }
      window.addEventListener('mousemove', mm);
      window.addEventListener('mouseup', up);
    }

    // Helper functions
    function screenToWorld(sx, sy){
      const rect = viewport.getBoundingClientRect();
      const x = (sx - rect.left - state.origin.x) / state.zoom;
      const y = (sy - rect.top - state.origin.y) / state.zoom;
      return {x,y};
    }
    
    function intersects(a,b){ 
      return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.h+a.y > b.y; 
    }
    
    function clearSelection(){ 
      state.selection.forEach(id=>{
        const el = getElement(id);
        if(el) el.classList.remove('selected');
      }); 
      state.selection.clear(); 
    }
    
    function selectId(id, additive=false){ 
      if(!additive) clearSelection(); 
      state.selection.add(id); 
      const el = getElement(id);
      if(el) el.classList.add('selected');
    }
    
    function toggleSelect(id){ 
      const el = getElement(id);
      if(state.selection.has(id)){ 
        state.selection.delete(id); 
        if(el) el.classList.remove('selected'); 
      } else { 
        state.selection.add(id); 
        if(el) el.classList.add('selected'); 
      } 
    }
    
    function getElement(id){ return document.querySelector(`[data-id="${id}"]`); }
    function getNodeById(id){ return state.nodes.find(n=>n.id===id); }
    function getGroupById(id){ return state.groups.find(g=>g.id===id); }
    function getTextboxById(id){ return state.textboxes.find(t=>t.id===id); }
    function getTextboxByElement(element){ return state.textboxes.find(t=>t.element===element); }

    function deleteNode(node){ 
      node.el.remove(); 
      state.nodes = state.nodes.filter(n=>n!==node); 
      state.selection.delete(node.id); 
    }
    
    function duplicateNode(node){ 
      const at = {x: node.x + 20, y: node.y + 20}; 
      createNode(node.kind, node.assetUrl, {w: node.w, h: node.h}, at, node.meta); 
    }

    // File handling
    function handleFiles(fileList, atPos){
      console.log('Handling files:', fileList.length);
      if(!fileList || !fileList.length) return;
      let pos = atPos;
      if(!pos){
        const rect = viewport.getBoundingClientRect();
        pos = screenToWorld(rect.left + rect.width/2, rect.top + rect.height/2);
      }
      const offsetStep = 24;
      let idx = 0;
      Array.from(fileList).forEach(async (f)=>{
        const url = URL.createObjectURL(f);
        const kind = fileKindFromMime(f.type);
        let size = {w:360, h:240};
        
        if(kind==='video'){ size = {w:480, h:270}; }
        if(kind==='pdf'){ size = {w:420, h:300}; }

        const at = {x: pos.x - size.w/2 + (idx%5)*offsetStep, y: pos.y - size.h/2 + Math.floor(idx/5)*offsetStep};

        let extraMeta = { file: { name: f.name, type: f.type, size: f.size }, dimensions: null, exif: null };
        
        if(kind==='image'){
          await new Promise((resolve)=>{
            const img = new Image();
            img.onload = ()=>{ 
              const naturalW = img.naturalWidth;
              const naturalH = img.naturalHeight;
              extraMeta.dimensions = {w: naturalW, h: naturalH};
              size = calculateOptimalImageSize(naturalW, naturalH);
              at.x = pos.x - size.w/2 + (idx%5)*offsetStep;
              at.y = pos.y - size.h/2 + Math.floor(idx/5)*offsetStep;
              resolve(); 
            };
            img.onerror = ()=> resolve();
            img.src = url;
          });
        }

        createNode(kind, url, size, at, extraMeta);
        idx++;
      });
    }

    function calculateOptimalImageSize(naturalWidth, naturalHeight) {
      const maxDisplayWidth = 800;
      const maxDisplayHeight = 600;
      const minDisplayWidth = 160;
      const minDisplayHeight = 120;
      
      let displayWidth = naturalWidth;
      let displayHeight = naturalHeight;
      
      if (naturalWidth > maxDisplayWidth || naturalHeight > maxDisplayHeight) {
        const widthRatio = maxDisplayWidth / naturalWidth;
        const heightRatio = maxDisplayHeight / naturalHeight;
        const scale = Math.min(widthRatio, heightRatio);
        
        displayWidth = Math.round(naturalWidth * scale);
        displayHeight = Math.round(naturalHeight * scale);
      }
      
      if (naturalWidth < minDisplayWidth && naturalHeight < minDisplayHeight) {
        const widthRatio = minDisplayWidth / naturalWidth;
        const heightRatio = minDisplayHeight / naturalHeight;
        const scale = Math.min(widthRatio, heightRatio, 3);
        
        displayWidth = Math.round(naturalWidth * scale);
        displayHeight = Math.round(naturalHeight * scale);
      }
      
      displayWidth = Math.max(displayWidth, minDisplayWidth);
      displayHeight = Math.max(displayHeight, minDisplayHeight);
      
      return { w: displayWidth, h: displayHeight };
    }

    function fileKindFromMime(mime){
      if(mime.startsWith('image/')) return 'image';
      if(mime.startsWith('video/')) return 'video';
      if(mime==='application/pdf') return 'pdf';
      return 'image';
    }

    // Fixed Save/Load functions with proper textbox state management
    

function saveBoard(){
  console.log('Saving board.');
  const name = prompt('Enter a name for this board:', `Board_${new Date().toLocaleDateString()}`);
  if(!name) return;

  Promise.all([ exportBoardDataWithFiles(), captureBoardSnapshot() ])
    .then(([boardData, snap]) => {
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      savedBoards[name] = {
        data: boardData,
        snapshot: snap,
        timestamp: new Date().toISOString(),
        name
      };
      localStorage.setItem('moodboards', JSON.stringify(savedBoards));
      updateSavedBoardsList();
      alert(`Board "${name}" saved successfully with all file data!`);
    }).catch(error => {
      console.error('Save error:', error);
      alert('Error saving board: ' + error.message);
    });
}


    function exportBoard(){
  console.log('Exporting board...');
  const btn = document.querySelector('#btnExport');
  const originalText = btn ? btn.textContent : null;
  if(btn) btn.textContent = 'Exporting...';

  Promise.all([ exportBoardDataWithFiles(), captureBoardSnapshot() ])
    .then(([boardData, snap]) => {
      const dataStr = JSON.stringify(boardData, null, 2);
      downloadTextAs(`moodboard_export_${new Date().toISOString().split('T')[0]}.json`, dataStr);
      const name = boardData?.name || `Export_${new Date().toLocaleDateString()}`;
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      savedBoards[name] = {
        data: boardData,
        snapshot: snap,
        timestamp: new Date().toISOString(),
        name
      };
      localStorage.setItem('moodboards', JSON.stringify(savedBoards));
      updateSavedBoardsList();
      if(btn) btn.textContent = originalText;
      alert('Board exported successfully with all file data! Check your downloads folder.');
    })
    .catch(error => {
      console.error('Export error:', error);
      if(btn) btn.textContent = originalText;
      alert('Error exporting board: ' + error.message);
    });
}


    function importBoard(event){
      console.log('Importing board...');
      const file = event.target.files[0];
      if(!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const boardData = JSON.parse(e.target.result);
          loadBoardData(boardData);
          alert('Board imported successfully with all file data restored!');
        } catch (error) {
          console.error('Import error:', error);
          alert('Error importing board: Invalid JSON file');
        }
      };
      reader.readAsText(file);
      
      event.target.value = '';
    }

    async function exportBoardDataWithFiles() {
      const processedNodes = await Promise.all(state.nodes.map(async (node) => {
        const processedNode = {...node};
        
        delete processedNode.el;
        delete processedNode.metaTextbox;
        
        if(node.assetUrl && node.assetUrl.startsWith('blob:')) {
          try {
            const base64Data = await blobUrlToBase64(node.assetUrl);
            processedNode.assetUrl = base64Data;
            processedNode.isFileNode = true;
            processedNode.hasBase64Data = true;
          } catch (error) {
            console.error('Error converting file to base64:', error);
            processedNode.assetUrl = '[FILE_CONVERSION_ERROR]';
            processedNode.isFileNode = true;
            processedNode.hasBase64Data = false;
          }
        }
        
        return processedNode;
      }));

      // Fixed textbox processing with proper state saving
      const processedTextboxes = state.textboxes.map(textbox => {
        const el = textbox.element;
        
        // Get the actual content, handling placeholder text properly
        let content = '';
        let hasActualContent = false;
        
        if (!textbox.hasPlaceholder && textbox.element.textContent.trim() !== '') {
          content = el.innerHTML;
          hasActualContent = true;
        }
        
        return {
          id: textbox.id,
          content: content,
          hasPlaceholder: textbox.hasPlaceholder,
          hasActualContent: hasActualContent,
          left: el.style.left,
          top: el.style.top,
          width: el.style.width,
          height: el.style.height
        };
      });

      const processedGroups = state.groups.map(group => {
        const processedGroup = {...group};
        delete processedGroup.el;
        return processedGroup;
      });
      
      // Process checklist nodes for saving
      const processedChecklists = window.checklistNodes ? window.checklistNodes.map(checklist => {
        return {
          id: checklist.id,
          x: checklist.x,
          y: checklist.y,
          text: checklist.text,
          checked: checklist.checked
        };
      }) : [];

      return {
        version: '4.8',
        timestamp: new Date().toISOString(),
        hasBase64Files: true,
        viewport: {
          zoom: state.zoom,
          origin: state.origin
        },
        nodes: processedNodes,
        groups: processedGroups,
        textboxes: processedTextboxes,
        checklists: processedChecklists,
        nextId: state.nextId
      };
    }

    function blobUrlToBase64(blobUrl) {
      return new Promise((resolve, reject) => {
        fetch(blobUrl)
          .then(response => response.blob())
          .then(blob => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          })
          .catch(reject);
      });
    }

    function base64ToBlob(base64Data) {
      const parts = base64Data.split(',');
      const mimeMatch = parts[0].match(/:(.*?);/);
      const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
      const byteString = atob(parts[1]);
      const byteNumbers = new Array(byteString.length);
      
      for (let i = 0; i < byteString.length; i++) {
        byteNumbers[i] = byteString.charCodeAt(i);
      }
      
      const byteArray = new Uint8Array(byteNumbers);
      return new Blob([byteArray], {type: mime});
    }

    // Fixed loadBoardData with proper textbox restoration
    async function loadBoardData(boardData) {
      clearBoard();
      
      if(boardData.viewport) {
        state.zoom = boardData.viewport.zoom || 1;
        state.origin = boardData.viewport.origin || {x: 0, y: 0};
        applyTransform();
      }
      
      state.nextId = boardData.nextId || 1;
      
      // Restore groups
      if(boardData.groups) {
        boardData.groups.forEach(groupData => {
          const group = createGroup({x: groupData.x, y: groupData.y});
          Object.assign(group, groupData);
          group.el.style.width = group.w + 'px';
          group.el.style.height = group.h + 'px';
          group.el.style.borderColor = group.color;
          group.el.querySelector('.title').textContent = group.title;
        });
      }
      
      // Restore nodes with base64 file conversion
      if(boardData.nodes) {
        for(const nodeData of boardData.nodes) {
          let assetUrl = nodeData.assetUrl;
          
          if(nodeData.isFileNode && nodeData.hasBase64Data && nodeData.assetUrl.startsWith('data:')) {
            try {
              const blob = base64ToBlob(nodeData.assetUrl);
              assetUrl = URL.createObjectURL(blob);
            } catch (error) {
              console.error('Error converting base64 to blob:', error);
              console.warn('Skipping file node with conversion error:', nodeData.title);
              continue;
            }
          } else if(nodeData.isFileNode && !nodeData.hasBase64Data) {
            console.warn('Skipping file node with lost data:', nodeData.title);
            continue;
          }
          
          const node = createNode(
            nodeData.kind,
            assetUrl,
            {w: nodeData.w, h: nodeData.h},
            {x: nodeData.x, y: nodeData.y},
            nodeData.meta
          );
          
          node.title = nodeData.title;
          node.el.querySelector('.title').textContent = node.title;
        }
      }
      
      // Fixed textbox restoration with proper state management
      if(boardData.textboxes) {
        boardData.textboxes.forEach(textboxData => {
          const pos = {
            x: parseFloat(textboxData.left) || 0, 
            y: parseFloat(textboxData.top) || 0
          };
          
          // Create new textbox but don't auto-focus it
          const textbox = createFloatingTextbox(pos);
          
          // Restore ID and properties
          textbox.id = textboxData.id;
          textbox.element.dataset.id = textboxData.id;
          
          // Set dimensions
          if (textboxData.width) textbox.element.style.width = textboxData.width;
          if (textboxData.height) textbox.element.style.height = textboxData.height;
          
          // Restore content and placeholder state properly
          if (textboxData.hasActualContent && textboxData.content && textboxData.content.trim() !== '') {
            // Has real content - restore it
            textbox.element.innerHTML = textboxData.content;
            textbox.hasPlaceholder = false;
          } else {
            // Empty or placeholder - ensure placeholder is shown
            setPlaceholderText(textbox);
          }
          
          // Ensure proper state
          textbox.isEditing = false;
          textbox.element.blur();
        });
      }
      
      // Restore checklist nodes
      if(boardData.checklists && window.addChecklistNodeAt) {
        boardData.checklists.forEach(checklistData => {
          window.addChecklistNodeAt(
            checklistData.x,
            checklistData.y,
            checklistData.text,
            checklistData.checked
          );
        });
      }
    }

    function clearBoard() {
      state.nodes.forEach(node => {
        if(node.el) node.el.remove();
      });
      state.nodes = [];
      
      state.groups.forEach(group => {
        if(group.el) group.el.remove();
      });
      state.groups = [];
      
      state.textboxes.forEach(textbox => {
        if(textbox.element) textbox.element.remove();
      });
      state.textboxes = [];
      
      // Clear checklist nodes
      if(window.checklistNodes) {
        window.checklistNodes.forEach(checklist => {
          if(checklist.element) checklist.element.remove();
        });
        window.checklistNodes.length = 0;
      }
      
      clearSelection();
    }

    function updateSavedBoardsList() {
  const saveList = document.getElementById('saveList');
  const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');

  if (!saveList) return;

  saveList.innerHTML = '';

  const names = Object.keys(savedBoards);
  if (names.length === 0) {
    saveList.innerHTML = '<div style="text-align:center;color:var(--muted);font-size:12px;">No saved boards</div>';
    return;
  }

  names.forEach((name) => {
    const info = savedBoards[name] || {};
    const date = new Date(info.timestamp || Date.now()).toLocaleString();
    const hasFiles = info.data && info.data.hasBase64Files ? ' 📁' : '';
    const thumb = info.snapshot && info.snapshot.thumb;

    const card = document.createElement('div');
    card.className = 'save-card';
    card.innerHTML = `
      ${thumb ? `<img alt="Board snapshot" src="${thumb}">` : `<div style="height:96px;border-radius:8px;background:rgba(255,255,255,.08);display:grid;place-items:center;font-size:12px;color:var(--muted)">No Preview</div>`}
      <div class="meta">
        <div style="font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}${hasFiles}</div>
        <div>${date}</div>
      </div>
      <div class="row">
        <button data-act="load" data-name="${name}">Load</button>
        <button data-act="json" data-name="${name}">JSON</button>
        <button data-act="png"  data-name="${name}">PNG</button>
        <button data-act="del"  data-name="${name}" class="danger">Delete</button>
      </div>
    `;
    saveList.appendChild(card);
  });

  saveList.onclick = (e)=>{
    const btn = e.target.closest('button'); if(!btn) return;
    const act = btn.getAttribute('data-act');
    const name = btn.getAttribute('data-name');
    const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
    const info = savedBoards[name]; if(!info) return;

    if (act === 'load') {
      if (confirm(`Load board "${name}"? This will replace your current board.`)) {
        loadBoardData(info.data);
        alert(`Board "${name}" loaded successfully!`);
      }
    } else if (act === 'json') {
      const dataStr = JSON.stringify(info.data || {}, null, 2);
      downloadTextAs(`${name}.json`, dataStr);
    } else if (act === 'png') {
      const full = (info.snapshot && (info.snapshot.full || info.snapshot.thumb));
      if (full) downloadDataUrl(full, `${name}.png`);
      else alert('No PNG available for this item.');
    } else if (act === 'del') {
      if (confirm(`Delete board "${name}"? This cannot be undone.`)) {
        delete savedBoards[name];
        localStorage.setItem('moodboards', JSON.stringify(savedBoards));
        updateSavedBoardsList();
        alert(`Board "${name}" deleted.`);
      }
    }
  };
}


    function loadSavedBoard(name) {
      const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
      const boardInfo = savedBoards[name];
      
      if(!boardInfo) {
        alert('Board not found!');
        return;
      }
      
      if(confirm(`Load board "${name}"? This will replace your current board.`)) {
        loadBoardData(boardInfo.data);
        alert(`Board "${name}" loaded successfully!`);
      }
    }

    function deleteSavedBoard(name) {
      if(confirm(`Delete board "${name}"? This cannot be undone.`)) {
        const savedBoards = JSON.parse(localStorage.getItem('moodboards') || '{}');
        delete savedBoards[name];
        localStorage.setItem('moodboards', JSON.stringify(savedBoards));
        updateSavedBoardsList();
        alert(`Board "${name}" deleted.`);
      }
    }

    function loadSavedBoards(){
      console.log('Loading saved boards list...');
      updateSavedBoardsList();
    }

    // Make functions globally available for onclick handlers
    window.loadSavedBoard = loadSavedBoard;
    window.deleteSavedBoard = deleteSavedBoard;

    // Initialize the app
    console.log('About to initialize...');
    init();
  
    // === Shift + Drag to move textboxes (without interfering with typing) ===
    (function enableShiftDragTextboxes(){
      document.addEventListener('mousedown', (e)=>{
        const tb = e.target.closest('.textbox');
        if(!tb) return;
        // Ignore the resize handle, and only act when Shift is held
        if (!e.shiftKey || e.target.classList.contains('tb-resizer')) return;

        // Prevent canvas pan/selection; we'll move the textbox itself
        e.preventDefault();
        e.stopPropagation();

        // World-space helpers
        function screenToWorldLocal(sx, sy){
          try{
            if (typeof screenToWorld === 'function') return screenToWorld(sx, sy);
          }catch(_e){}
          const vp = document.getElementById('viewport');
          const rect = vp.getBoundingClientRect();
          const zoom = (window.state && window.state.zoom) ? window.state.zoom : 1;
          const origin = (window.state && window.state.origin) ? window.state.origin : {x:0,y:0};
          const x = (sx - rect.left - origin.x) / zoom;
          const y = (sy - rect.top  - origin.y) / zoom;
          return {x,y};
        }

        // Establish starting positions in world coords
        const startWorld = screenToWorldLocal(e.clientX, e.clientY);
        const startLeft = parseFloat(tb.style.left) || 0;
        const startTop  = parseFloat(tb.style.top)  || 0;

        // Visual feedback
        const prevCursor = tb.style.cursor;
        tb.style.cursor = 'grabbing';
        tb.classList.add('dragging');

        // Disable text selection while dragging
        const prevUserSelect = document.body.style.userSelect;
        document.body.style.userSelect = 'none';

        function onMove(ev){
          const w = screenToWorldLocal(ev.clientX, ev.clientY);
          const dx = w.x - startWorld.x;
          const dy = w.y - startWorld.y;
          tb.style.left = (startLeft + dx) + 'px';
          tb.style.top  = (startTop  + dy) + 'px';
          // <— add this
          if (window.updateAllWires) window.updateAllWires();
        }
        function onUp(){
          window.removeEventListener('mousemove', onMove);
          window.removeEventListener('mouseup', onUp);
          tb.style.cursor = prevCursor;
          tb.classList.remove('dragging');
          document.body.style.userSelect = prevUserSelect;
        }
        window.addEventListener('mousemove', onMove, {passive:false});
        window.addEventListener('mouseup', onUp, {passive:false});
      }, true); // capture to beat other handlers
    })();
</script>

<script>
(function(){
  const board = document.querySelector('#board, .board, #canvas, .canvas') || document.body;

  // ---- Helpers: Bezier math ----
  function bezierPoint(a,c1,c2,b,t){
    const mt = 1-t, mt2 = mt*mt, t2 = t*t;
    const x = a.x*mt*mt2 + 3*c1.x*t*mt2 + 3*c2.x*t2*mt + b.x*t*t2;
    const y = a.y*mt*mt2 + 3*c1.y*t*mt2 + 3*c2.y*t2*mt + b.y*t*t2;
    return {x,y};
  }
  function bezierDeriv(a,c1,c2,b,t){
    const mt = 1-t;
    const x = 3*mt*mt*(c1.x - a.x) + 6*mt*t*(c2.x - c1.x) + 3*t*t*(b.x - c2.x);
    const y = 3*mt*mt*(c1.y - a.y) + 6*mt*t*(c2.y - c1.y) + 3*t*t*(b.y - c2.y);
    return {x,y};
  }
  // Solve C1 so that B(t1) = P  (linear in C1)
  function solveC1FromPoint(a,c2,b,t,P){
    const mt = 1-t, mt2 = mt*mt, t2 = t*t;
    const denom = 3*mt2*t || 1e-6;
    return {
      x: (P.x - (a.x*mt*mt2 + 3*c2.x*t2*mt + b.x*t*t2)) / denom,
      y: (P.y - (a.y*mt*mt2 + 3*c2.y*t2*mt + b.y*t*t2)) / denom
    };
  }
  // Solve C2 so that B(t2) = P  (linear in C2)
  function solveC2FromPoint(a,c1,b,t,P){
    const mt = 1-t, mt2 = mt*mt, t2 = t*t;
    const denom = 3*mt*t2 || 1e-6;
    return {
      x: (P.x - (a.x*mt*mt2 + 3*c1.x*t*mt2 + b.x*t*t2)) / denom,
      y: (P.y - (a.y*mt*mt2 + 3*c1.y*t*mt2 + b.y*t*t2)) / denom
    };
  }

  // ---- Wires layer (below nodes) ----
  function ensureWiresLayer(){
    let svg = document.getElementById('wires');
    if (!svg){
      svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.id = 'wires';
      svg.setAttribute('viewBox','0 0 50000 50000');
      svg.setAttribute('width','50000');
      svg.setAttribute('height','50000');
      // insert as FIRST CHILD to ensure it's behind other absolute layers
      board.insertBefore(svg, board.firstChild || null);
    } else if (svg !== board.firstChild){
      // always keep it first
      board.insertBefore(svg, board.firstChild || null);
    }
    return svg;
  }

  // ---- State ----
  window.state = window.state || {};
  state.wires = state.wires || [];
  state.connecting = state.connecting || null;

  function getCenter(el){
    return {
      x: (parseFloat(el.style.left)||0) + el.offsetWidth/2,
      y: (parseFloat(el.style.top)||0)  + el.offsetHeight/2
    };
  }

  // create wire
  function makeWire(fromEl, toEl){
    const svg = ensureWiresLayer();
    const g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.classList.add('wire');
    const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.classList.add('wire-path');

    // on-wire handles (groups with icon + hit + dot)
    function makeHandle(){
      const hg = document.createElementNS('http://www.w3.org/2000/svg','g'); hg.classList.add('wire-handle');
      const hit = document.createElementNS('http://www.w3.org/2000/svg','circle'); hit.setAttribute('class','hit'); hit.setAttribute('r','12');
      const dot = document.createElementNS('http://www.w3.org/2000/svg','circle'); dot.setAttribute('class','dot'); dot.setAttribute('r','4.5');
      const icon = document.createElementNS('http://www.w3.org/2000/svg','path'); icon.setAttribute('class','icon');
      icon.setAttribute('d','M -8 0 Q -4 -6 0 0 T 8 0'); // small S-curve
      hg.appendChild(hit); hg.appendChild(dot); hg.appendChild(icon);
      return hg;
    }
    const h1 = makeHandle(), h2 = makeHandle();

    g.appendChild(path); g.appendChild(h1); g.appendChild(h2);
    svg.appendChild(g);

    const a = getCenter(fromEl);
    const b = toEl ? getCenter(toEl) : a;
    const defaultMag = Math.min(240, Math.max(80, Math.abs(b.x-a.x)*.35));
    const sign = (b.x - a.x) >= 0 ? 1 : -1;

    const wire = {
      fromEl, toEl: toEl || null, g, path, h1, h2,
      c1: { x: a.x + sign*defaultMag, y: a.y },
      c2: { x: b.x - sign*defaultMag, y: b.y },
      tempTarget: null
    };

    // handles only visible after attached
    if (!toEl){ h1.style.display='none'; h2.style.display='none'; }

    // dragging on-wire handles -> solve for C1/C2 at t=⅓,⅔
    function startHandleDrag(which, down){
      down.preventDefault(); down.stopPropagation();
      const t = (which===1) ? 1/3 : 2/3;
      const handle = (which===1) ? h1 : h2;
      handle.classList.add('dragging');

      function move(ev){
        const W = (typeof screenToWorld==='function') ? screenToWorld(ev.clientX, ev.clientY) : {x:ev.clientX,y:ev.clientY};
        const A = getCenter(wire.fromEl);
        const B = wire.toEl ? getCenter(wire.toEl) : (wire.tempTarget || A);
        if (which===1){
          wire.c1 = solveC1FromPoint(A, wire.c2, B, t, W);
        }else{
          wire.c2 = solveC2FromPoint(A, wire.c1, B, t, W);
        }
        updateWire(wire);
      }
      function up(){
        window.removeEventListener('mousemove', move, true);
        window.removeEventListener('mouseup', up, true);
        handle.classList.remove('dragging');
      }
      window.addEventListener('mousemove', move, true);
      window.addEventListener('mouseup', up, true);
    }
    h1.addEventListener('mousedown', (e)=>startHandleDrag(1,e), true);
    h2.addEventListener('mousedown', (e)=>startHandleDrag(2,e), true);

    state.wires.push(wire);
    updateWire(wire);
    return wire;
  }

  function updateWire(wire){
    // cleanup
    if (!wire.fromEl?.isConnected || (wire.toEl && !wire.toEl.isConnected)){
      try{ wire.g.remove(); }catch(_){}
      state.wires = state.wires.filter(w=>w!==wire);
      return;
    }
    const A = getCenter(wire.fromEl);
    const B = wire.toEl ? getCenter(wire.toEl) : (wire.tempTarget || A);
    const C1 = wire.c1, C2 = wire.c2;

    // path
    wire.path.setAttribute('d', `M ${A.x} ${A.y} C ${C1.x} ${C1.y}, ${C2.x} ${C2.y}, ${B.x} ${B.y}`);

    // handles on-curve at t=1/3 and t=2/3
    const t1 = 1/3, t2 = 2/3;
    const P1 = bezierPoint(A,C1,C2,B,t1), T1 = bezierDeriv(A,C1,C2,B,t1);
    const P2 = bezierPoint(A,C1,C2,B,t2), T2 = bezierDeriv(A,C1,C2,B,t2);
    const a1 = Math.atan2(T1.y,T1.x)*180/Math.PI;
    const a2 = Math.atan2(T2.y,T2.x)*180/Math.PI;

    wire.h1.setAttribute('transform', `translate(${P1.x} ${P1.y}) rotate(${a1})`);
    wire.h2.setAttribute('transform', `translate(${P2.x} ${P2.y}) rotate(${a2})`);
  }

  function updateAllWires(){ state.wires.slice().forEach(updateWire); }
  window.updateAllWires = updateAllWires;

  // ---- Connection mode (block node actions while connecting) ----
  function startConnectFrom(el){
    ensureWiresLayer();

    const temp = makeWire(el, null);
    temp.g.classList.add('connecting');

    let hoverEl = null;
    function setHover(el2){
      if (hoverEl === el2) return;
      if (hoverEl) hoverEl.classList.remove('connect-hover');
      hoverEl = el2;
      if (hoverEl) hoverEl.classList.add('connect-hover');
    }

    function onMove(e){
      const W = (typeof screenToWorld==='function') ? screenToWorld(e.clientX,e.clientY) : {x:e.clientX,y:e.clientY};
      temp.tempTarget = W;
      updateWire(temp);
      const hit = document.elementFromPoint(e.clientX, e.clientY);
      const cand = hit?.closest && hit.closest('.node, .textbox, .checknode');
      setHover(cand && cand!==el ? cand : null);
    }

    function onDown(e){
      const target = hoverEl;
      setHover(null);

      if (target && target!==el){
        temp.toEl = target;
        temp.h1.style.display=''; temp.h2.style.display='';
        updateWire(temp);
      } else {
        try{ temp.g.remove(); }catch(_){}
        state.wires = state.wires.filter(w=>w!==temp);
      }
      end();
    }

    function end(){
      window.removeEventListener('mousemove', onMove, true);
      window.removeEventListener('mousedown', onDown, true);
      state.connecting = null;
      document.documentElement.classList.remove('connecting');
    }

    state.connecting = { wire: temp, fromEl: el };
    document.documentElement.classList.add('connecting');

    // High-priority listeners
    window.addEventListener('mousemove', onMove, true);
    window.addEventListener('mousedown', onDown, true);
  }
  window.__startConnectFrom = startConnectFrom;

  // Global blocker: while connecting, prevent clicks from triggering node/textbox actions.
  function blockWhileConnecting(e){
    if (!state.connecting) return;
    if (e.target?.closest && e.target.closest('.node, .textbox, .checknode')){
      e.preventDefault();
      e.stopImmediatePropagation();
    }
  }
  ['mousedown','click','mouseup','dblclick'].forEach(type=>{
    document.addEventListener(type, blockWhileConnecting, true); // capture
  });

  // Keep wires fresh on zoom/pan (wrap applyTransform if present)
  if (typeof window.applyTransform === 'function'){
    const __apply = window.applyTransform;
    window.applyTransform = function(...args){
      const r = __apply.apply(this, args);
      if (window.updateAllWires) window.updateAllWires();
      return r;
    };
  }

  // Ensure layer order on first run
  ensureWiresLayer();
})();
</script>

<script>
// ===== Standalone Checklist Node + Board Context Menu =====
(function(){
  // Try to find your board element; fall back to document.body
  // If your board container has a specific ID/class, put it first in the selector list:
  const board = document.querySelector('#board, .board, #canvas, .canvas') || document.body;

  // Keep track of checklist nodes for save/load integration
  const checklistNodes = [];

  // Bring-to-front helper via z-index bump
  let zTop = 2000;
  function bringToFront(el){ el.style.zIndex = ++zTop; }

  // Core: create a draggable checklist node
  function createChecklistNode(x, y, textValue = 'New item', checked = false){
    const id = 'c' + Date.now() + Math.random().toString(36).substr(2, 9);
    const node = document.createElement('div');
    node.className = 'checknode';
    node.dataset.type = 'checknode';
    node.dataset.id = id;
    node.setAttribute('role', 'group');

    // Drag handle
    const grip = document.createElement('span');
    grip.className = 'drag-handle';
    grip.setAttribute('aria-label', 'Drag checklist');
    grip.setAttribute('role', 'button');

    // Checkbox
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !!checked;

    // Single-line text (editable)
    const text = document.createElement('div');
    text.className = 'checktext';
    text.contentEditable = 'true';
    text.textContent = textValue;

    node.appendChild(grip);
    node.appendChild(cb);
    node.appendChild(text);

    // Initial position
    node.style.left = Math.round(x) + 'px';
    node.style.top  = Math.round(y) + 'px';
    bringToFront(node);

    // Create checklist data object
    const checklistData = {
      id: id,
      x: x,
      y: y,
      text: textValue,
      checked: checked,
      element: node
    };
    
    // Add to tracking array
    checklistNodes.push(checklistData);

    // Toggle visual on check (removed strikethrough)
    const syncChecked = ()=> {
      // Update data when checkbox changes
      checklistData.checked = cb.checked;
    };
    cb.addEventListener('change', syncChecked);
    syncChecked();
    
    // Update data when text changes
    text.addEventListener('input', ()=> {
      checklistData.text = text.textContent;
    });
    text.addEventListener('blur', ()=> {
      checklistData.text = text.textContent;
    });

    // ---- Drag logic (handle-only) ----
    let dragging = false;

    function startDrag(e){
      e.preventDefault();
      e.stopPropagation(); // Prevent canvas pan/selection
      bringToFront(node);
      dragging = true;
      node.setAttribute('aria-grabbed', 'true');
      // Use world-space coordinates (accounts for zoom + origin)
      const toWorld = (sx, sy) => {
        if (typeof screenToWorld === 'function') return screenToWorld(sx, sy);
        // Fallback (shouldn't be needed in your app)
        const vp = document.getElementById('viewport');
        const rect = vp.getBoundingClientRect();
        const zoom = (typeof state !== 'undefined' && state.zoom) ? state.zoom : 1;
        const origin = (typeof state !== 'undefined' && state.origin) ? state.origin : {x:0,y:0};
        return { x: (sx - rect.left - origin.x) / zoom,
                 y: (sy - rect.top  - origin.y) / zoom };
      };
      const startWorld = toWorld(e.clientX, e.clientY);
      const startLeft  = parseFloat(node.style.left) || 0;
      const startTop   = parseFloat(node.style.top)  || 0;
      // Multiselect: capture start positions for all selected items
      const selectedIds = (typeof state!=='undefined' && state.selection && state.selection.size)
        ? Array.from(state.selection)
        : [id];
      if(selectedIds.indexOf(id)===-1) selectedIds.push(id);
      const startPositions = {};
      selectedIds.forEach(sid=>{
        let n = (typeof getNodeById==='function') && getNodeById(sid);
        let g = (typeof getGroupById==='function') && getGroupById(sid);
        let t = (typeof getTextboxById==='function') && getTextboxById(sid);
        let c = (window.checklistNodes||[]).find(c=>c.id===sid);
        if(n) startPositions[sid] = {x:n.x, y:n.y, type:'node'};
        else if(g) startPositions[sid] = {x:g.x, y:g.y, type:'group'};
        else if(t) startPositions[sid] = {x:parseFloat(t.element.style.left), y:parseFloat(t.element.style.top), type:'textbox'};
        else if(c) startPositions[sid] = {x:c.x, y:c.y, type:'check'};
      });
      function onMove(ev){
        if (!dragging) return;
        const w = toWorld(ev.clientX, ev.clientY);
        const dx = Math.round(w.x - startWorld.x);
        const dy = Math.round(w.y - startWorld.y);
        selectedIds.forEach(sid=>{
          const sp = startPositions[sid]; if(!sp) return;
          if(sp.type==='node'){
            const n = getNodeById(sid); if(n){ n.x = sp.x + dx; n.y = sp.y + dy; n.el.style.left = n.x+'px'; n.el.style.top = n.y+'px'; }
          } else if(sp.type==='group'){
            const g = getGroupById(sid); if(g){ g.x = sp.x + dx; g.y = sp.y + dy; g.el.style.left = g.x+'px'; g.el.style.top = g.y+'px'; }
          } else if(sp.type==='textbox'){
            const t = getTextboxById(sid); if(t){ const nx = sp.x + dx, ny = sp.y + dy; t.element.style.left = nx+'px'; t.element.style.top = ny+'px'; }
          } else if(sp.type==='check'){
            const c = (window.checklistNodes||[]).find(c=>c.id===sid); if(c && c.element){ c.x = sp.x + dx; c.y = sp.y + dy; c.element.style.left = c.x+'px'; c.element.style.top = c.y+'px'; }
          }
        });
        if (window.updateAllWires) window.updateAllWires();
      }
      function endDrag(ev){
        if (ev){ ev.preventDefault(); ev.stopPropagation(); }
        dragging = false;
        node.setAttribute('aria-grabbed', 'false');
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', endDrag);
      }
      window.addEventListener('mousemove', onMove, { passive: false });
      window.addEventListener('mouseup', endDrag, { passive: false });
    }

    // Start drag ONLY from the handle
    grip.addEventListener('mousedown', startDrag);

    // Keep clicks on checkbox/text behaving normally, but prevent canvas interaction
    node.addEventListener('mousedown', (e)=>{
      e.stopPropagation(); // Always prevent canvas interaction
      if (e.target === grip) return; // drag via grip already handled
      const additive = e.shiftKey || e.metaKey || e.ctrlKey;
      if(additive){ if(typeof toggleSelect==='function') toggleSelect(id); }
      else { if(typeof selectId==='function') selectId(id); }
    });
    
    // Prevent any canvas interaction when clicking anywhere on the checklist
    node.addEventListener('click', (e)=>{
      e.stopPropagation();
    });

    // Optional: Enter creates a new sibling node below (Shift+Enter stays in current)
    text.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        const belowY = (parseFloat(node.style.top)||0) + node.offsetHeight + 8;
        const nx = (parseFloat(node.style.left)||0);
        const nn = createChecklistNode(nx, belowY, '', false);
        // Focus new node's text
        setTimeout(()=>{
          const t = nn.element.querySelector('.checktext');
          const r = document.createRange(); const s = window.getSelection();
          r.selectNodeContents(t); r.collapse(false); s.removeAllRanges(); s.addRange(r);
          t.focus();
        }, 0);
      }
    });

    board.appendChild(node);
    // Focus text right after creation
    setTimeout(()=>{
      const r = document.createRange(); const s = window.getSelection();
      r.selectNodeContents(text); r.collapse(false); s.removeAllRanges(); s.addRange(r);
      text.focus();
    }, 0);

    return checklistData; // Return the data object instead of the node
  }

  // Public API for integration with existing canvas menu
  window.addChecklistNodeAt = (x, y, text, checked)=> createChecklistNode(x,y,text,checked);
  
  // Expose checklist nodes array for save/load integration
  window.checklistNodes = checklistNodes;
})();

  

// === Instagram helpers (final) ===
function extractInstagramEmbed(url){
  const typeMatch = url.match(/(?:reel|reels|p|tv)/i);
  const codeMatch = url.match(/(?:reel|reels|p|tv)\/([A-Za-z0-9_-]+)/i);
  if(!typeMatch || !codeMatch) return null;
  const type = typeMatch[0].toLowerCase().replace('reels','reel');
  const shortcode = codeMatch[1].replace(/[^A-Za-z0-9_-].*$/, '');
  const embedUrl = `https://www.instagram.com/${type}/${shortcode}/embed`;
  const ar = (type === 'p') ? 0.8 : (9/16);
  return { embedUrl, shortcode, type, ar };
}

function createInstagramNode(originalUrl, at){
  const parsed = extractInstagramEmbed(originalUrl);
  if(!parsed){ alert('Invalid Instagram URL'); return; }
  const size = (parsed.type==='p') ? { w: 480, h: 600 } : { w: 420, h: 740 };
  const meta = {
    platform: 'instagram',
    type: parsed.type,
    shortcode: parsed.shortcode,
    embedUrl: parsed.embedUrl,
    originalUrl: originalUrl,
    ar: parsed.ar
  };
  if (typeof window.createNode === 'function') {
    return window.createNode('website', parsed.embedUrl, size, at, meta);
  }
  if (typeof window.createWebsiteNode === 'function') {
    return window.createWebsiteNode(parsed.embedUrl, at);
  }
  console.warn('No node creator found for Instagram.');
}

// === Video helpers ===
function ensureHlsJs(){
  return new Promise((resolve, reject)=>{
    if (window.Hls) return resolve(window.Hls);
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/hls.js@latest';
    script.async = true;
    script.onload = ()=> resolve(window.Hls);
    script.onerror = ()=> reject(new Error('Failed to load hls.js'));
    document.head.appendChild(script);
  });
}
function createVideoNode(src, at, opts){
  const size = { w: 640, h: 360 };
  const meta = { platform:'video', src, type: (opts && opts.kind) || 'file' };
  if (typeof window.createNode === 'function') {
    return window.createNode('video', src, size, at, meta);
  }
  // Fallback: website path if createNode is unavailable
  if (typeof window.createWebsiteNode === 'function') {
    return window.createWebsiteNode(src, at);
  }
}

</script>


<script>
// === X (Twitter) helpers ===
function extractTweetId(url){
  const m = url.match(/status\/(\d+)/);
  return m ? m[1] : null;
}
function ensureTwitterWidgets(){
  return new Promise((resolve, reject)=>{
    if (window.twttr && window.twttr.widgets) return resolve(window.twttr);
    if (document.querySelector('script[src*="platform.twitter.com/widgets.js"]')) {
      let tries = 0;
      const t = setInterval(()=>{
        tries++;
        if (window.twttr && window.twttr.widgets){ clearInterval(t); resolve(window.twttr); }
        if (tries>50){ clearInterval(t); reject(new Error('Twitter widgets not ready')); }
      }, 100);
      return;
    }
    const s = document.createElement('script');
    s.async = true;
    s.src = 'https://platform.twitter.com/widgets.js';
    s.charset = 'utf-8';
    s.onload = ()=> resolve(window.twttr || {});
    s.onerror = ()=> reject(new Error('Failed to load Twitter widgets.js'));
    document.head.appendChild(s);
  });
}
function createTwitterNode(originalUrl, at){
  const id = extractTweetId(originalUrl);
  if(!id){ alert('Invalid X/Twitter URL'); return; }
  const size = { w: 600, h: 560 };
  const meta = { platform:'twitter', tweetId:id, originalUrl: originalUrl };
  if (typeof window.createNode === 'function') {
    return window.createNode('twitter', originalUrl, size, at, meta);
  }
  if (typeof window.createWebsiteNode === 'function') {
    return window.createWebsiteNode(originalUrl, at);
  }
}
</script>

  <!-- Floating Text Toolbar (injected) -->
  <aside id="textToolbar" class="ftb" aria-label="Text formatting toolbar">
    <div class="ftb-row">
      <button id="tbBold"      class="ftb-btn" title="Bold"><span>𝐁</span></button>
      <button id="tbItalic"    class="ftb-btn" title="Italic"><span>𝑖</span></button>
      <button id="tbUnderline" class="ftb-btn" title="Underline"><span>U̲</span></button>
      <button id="tbStrike"    class="ftb-btn" title="Strikethrough"><span>S̶</span></button>

      <div class="ftb-sep"></div>

      <label class="ftb-swatch" title="Text color"><input id="tbColor" type="color" value="#ffffff"/></label>
      <label class="ftb-swatch" title="Highlight"><input id="tbBg" type="color" value="#2f80ed"/></label>

      <div class="ftb-sep"></div>

      <select id="tbFont" class="ftb-select" title="Font family">
        <option value="system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">System UI</option>
        <option value="Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">Inter</option>
        <option value="Arial, Helvetica, sans-serif">Arial</option>
        <option value="Helvetica, Arial, sans-serif">Helvetica</option>
        <option value="'Times New Roman', Times, serif">Times New Roman</option>
        <option value="Georgia, 'Times New Roman', Times, serif">Georgia</option>
        <option value="'Courier New', Courier, monospace">Courier New</option>
        <option value="Menlo, Monaco, Consolas, 'Courier New', monospace">Menlo</option>
        <option value="Verdana, Geneva, Tahoma, sans-serif">Verdana</option>
        <option value="'Noto Sans', system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif">Noto Sans</option>
        <option value="'Noto Serif', Georgia, 'Times New Roman', Times, serif">Noto Serif</option>
      </select>

      <input id="tbFontSize" class="ftb-number" type="number" min="8" max="200" step="1" value="16" title="Font size (px)" />
      <span class="ftb-unit">px</span>

      <div class="ftb-sep"></div>

      <button id="tbAlignL" class="ftb-btn" title="Align left">⟸</button>
      <button id="tbAlignC" class="ftb-btn" title="Center">╷</button>
      <button id="tbAlignR" class="ftb-btn" title="Align right">⟹</button>
      <button id="tbAlignJ" class="ftb-btn" title="Justify">≋</button>

      <div class="ftb-sep"></div>

      <input id="tbLink" class="ftb-link" type="text" placeholder="https://…"/>
      <button id="tbMakeLink" class="ftb-btn" title="Make link">🔗</button>
      <button id="tbUnlink"   class="ftb-btn" title="Remove link">✖︎</button>

      <div class="ftb-sep"></div>

      <button id="tbClear"    class="ftb-btn" title="Clear formatting">⌫</button>
    </div>
  </aside>


<script>
(function(){
  const bar = document.getElementById('textToolbar');
  const MIN_OFFSET = -100, MARGIN = 8;
  let activeTextbox = null, savedRange = null;

  const isIn = (el, host) => !!(el && host && host.contains(el));
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const getRange = () => { const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return null; return sel.getRangeAt(0); };
  const saveSelection = () => { const r = getRange(); if (r) savedRange = r.cloneRange(); };
  const restoreSelection = () => { const sel = window.getSelection(); if (!sel || !savedRange) return; sel.removeAllRanges(); sel.addRange(savedRange); };

  function positionToTextbox(){
    if (!activeTextbox || !document.body.contains(activeTextbox)) { hideBar(); return; }
    const rect = activeTextbox.getBoundingClientRect();
    bar.classList.add('is-visible');
    const tbw = bar.offsetWidth, tbh = bar.offsetHeight;
    const vw = document.documentElement.clientWidth, vh = document.documentElement.clientHeight;
    let left = rect.left + (rect.width/2) - (tbw/2);
    left = clamp(Math.round(left), MARGIN, vw - tbw - MARGIN);
    let top = rect.top + MIN_OFFSET;
    if (top + tbh + MARGIN > vh) top = Math.max(MARGIN, vh - tbh - MARGIN);
    bar.style.left = left + 'px'; bar.style.top  = Math.round(top) + 'px';
  }
  function showBarForTextbox(tb){ activeTextbox = tb; bar.classList.add('is-visible'); positionToTextbox(); saveSelection(); }
  function hideBar(){ bar.classList.remove('is-visible'); bar.style.left='-9999px'; bar.style.top='-9999px'; activeTextbox=null; }

  // Focus behavior: support .textbox or any contenteditable=true
  document.addEventListener('focusin', (e)=>{
    const tb = e.target.closest && (e.target.closest('.textbox') || e.target.closest('[contenteditable=\"true\"]'));
    if (tb) showBarForTextbox(tb);
  });
  document.addEventListener('mousedown', (e)=>{
    const target = e.target;
    const inToolbar = isIn(target, bar);
    const tb = target.closest && (target.closest('.textbox') || target.closest('[contenteditable=\"true\"]'));
    if (inToolbar || (tb && tb === activeTextbox)) return;
    if (tb && tb !== activeTextbox) { showBarForTextbox(tb); return; }
    hideBar();
  }, true);
  window.addEventListener('resize', positionToTextbox);
  window.addEventListener('scroll', positionToTextbox, true);
  bar.addEventListener('mousedown', (e)=>{
    if (e.target.closest('input, select, textarea')) { saveSelection(); return; }
    e.preventDefault(); restoreSelection();
  });

  // Keep savedRange synced with current selection inside active textbox
  document.addEventListener('selectionchange', function(){
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0 || !activeTextbox) return;
    const r = sel.getRangeAt(0);
    const node = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentNode;
    if (activeTextbox && activeTextbox.contains(node)) { savedRange = r.cloneRange(); }
  });
  document.addEventListener('mouseup', function(){
    const r = getRange(); if (!r || !activeTextbox) return;
    const node = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentNode;
    if (activeTextbox.contains(node)) savedRange = r.cloneRange();
  });
  document.addEventListener('keyup', function(){
    const r = getRange(); if (!r || !activeTextbox) return;
    const node = r.commonAncestorContainer.nodeType === 1 ? r.commonAncestorContainer : r.commonAncestorContainer.parentNode;
    if (activeTextbox.contains(node)) savedRange = r.cloneRange();
  });

  // Inline style helper
  function cssProp(name){ return name.replace(/[A-Z]/g, m => '-' + m.toLowerCase()); }
  function applyInlineStyle(styleObj) {
    restoreSelection();
    const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    let css=''; for (const k in styleObj) css += cssProp(k) + ':' + styleObj[k] + ';';
    span.setAttribute('style', css);
    if (range.collapsed) {
      span.appendChild(document.createTextNode('\u200b'));
      range.insertNode(span);
      const r = document.createRange(); r.setStart(span.firstChild, 1); r.collapse(true); sel.removeAllRanges(); sel.addRange(r);
    } else {
      const frag = range.cloneContents(); span.appendChild(frag); range.deleteContents(); range.insertNode(span);
      const r = document.createRange(); r.selectNodeContents(span); r.collapse(false); sel.removeAllRanges(); sel.addRange(r);
    }
    positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true});
  }

  // Align blocks intersecting the selection (fallback to textbox itself)
  function setAlignment(align){
    restoreSelection();
    const sel = window.getSelection(); if (!sel || sel.rangeCount === 0 || !activeTextbox) return;
    const range = sel.getRangeAt(0);
    const blocks = Array.from(activeTextbox.querySelectorAll('p,div,li,h1,h2,h3,h4,h5,h6'));
    let applied = false;
    blocks.forEach(el => { if (range.intersectsNode(el)) { el.style.textAlign = (align === 'justify' ? 'justify' : align); applied = true; } });
    if (!applied) { activeTextbox.style.textAlign = (align === 'justify' ? 'justify' : align); }
    positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true});
  }

  function onRelease(el, fn){ if (!el) return; el.addEventListener('mouseup', (e)=>{ if (e.button !== 0) return; fn(e); }); el.addEventListener('touchend', (e)=>{ fn(e); }, {passive:false}); }
  const exec = (cmd, val=null) => { restoreSelection(); document.execCommand(cmd,false,val); positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true}); };

  // Buttons
  onRelease(document.getElementById('tbBold'),      ()=> exec('bold'));
  onRelease(document.getElementById('tbItalic'),    ()=> exec('italic'));
  onRelease(document.getElementById('tbUnderline'), ()=> exec('underline'));
  onRelease(document.getElementById('tbStrike'),    ()=> exec('strikeThrough'));

  // Align
  onRelease(document.getElementById('tbAlignL'),    ()=> setAlignment('left'));
  onRelease(document.getElementById('tbAlignC'),    ()=> setAlignment('center'));
  onRelease(document.getElementById('tbAlignR'),    ()=> setAlignment('right'));
  onRelease(document.getElementById('tbAlignJ'),    ()=> setAlignment('justify'));

  // Clear
  onRelease(document.getElementById('tbClear'),     ()=> { restoreSelection(); document.execCommand('removeFormat'); document.execCommand('unlink'); positionToTextbox(); });

  // Colors on change
  document.getElementById('tbColor').addEventListener('change', (e)=> exec('foreColor', e.target.value));
  document.getElementById('tbBg').addEventListener('change', (e)=>{ restoreSelection(); if (!document.execCommand('hiliteColor', false, e.target.value)) document.execCommand('backColor', false, e.target.value); positionToTextbox(); });

  // Font family + size
  const fontSel = document.getElementById('tbFont');
  function updateFontPreview(){ fontSel.style.fontFamily = fontSel.value; }
  fontSel.addEventListener('change', ()=>{ applyInlineStyle({ fontFamily: fontSel.value }); updateFontPreview(); });
  updateFontPreview();

  const sizeInput = document.getElementById('tbFontSize');
  function applySize() { let px = parseInt(sizeInput.value, 10); if (isNaN(px)) return; px = Math.max(parseInt(sizeInput.min,10), Math.min(parseInt(sizeInput.max,10), px)); sizeInput.value = px; applyInlineStyle({ fontSize: px + 'px' }); }
  sizeInput.addEventListener('change', applySize);
  sizeInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') { e.preventDefault(); applySize(); } });

  // Links
  function makeLink(){
    let url = (document.getElementById('tbLink').value || '').trim(); if (!url) return;
    if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
    restoreSelection();
    const sel = window.getSelection(); if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    if (range.collapsed){
      const a = document.createElement('a'); a.href = url; a.target = '_blank'; a.rel='noopener noreferrer'; a.textContent = url;
      range.insertNode(a); range.setStartAfter(a); range.collapse(true); sel.removeAllRanges(); sel.addRange(range);
    } else {
      document.execCommand('createLink', false, url);
      let node = sel.focusNode; if (node && node.nodeType === 3) node = node.parentNode; const a = node && node.closest('a');
      if (a) { a.target = '_blank'; a.rel = 'noopener noreferrer'; a.href = url; }
    }
    positionToTextbox(); activeTextbox && activeTextbox.focus({preventScroll:true});
  }
  onRelease(document.getElementById('tbMakeLink'), makeLink);
  onRelease(document.getElementById('tbUnlink'), ()=> exec('unlink'));

  // Show for already-focused contenteditable
  if (document.activeElement && (document.activeElement.matches?.('.textbox,[contenteditable=\"true\"]'))) {
    showBarForTextbox(document.activeElement);
  }
})();
</script>


  <!-- Floating Spotlight Search -->
  <div id="spotlightOverlay" aria-hidden="true">
    <div class="spotlight-card" role="dialog" aria-modal="true" aria-label="Search the web">
      <div class="spotlight-row">
        <input id="spotlightInput" class="spotlight-input" type="text" placeholder="Search Google…" autocomplete="off">
        <button id="spotlightGo" class="spotlight-btn" title="Search Google">Search</button>
      </div>
      <div class="spotlight-hint">
        <span>Tip: Use quotes for exact matches.</span>
        <span><span class="kbd">Left Ctrl</span> + <span class="kbd">Space</span> to open • <span class="kbd">Esc</span> to close • <span class="kbd">Enter</span> to search</span>
      </div>
    </div>
  </div>


  <!-- Board context menu -->
  <div id="board-context" role="menu" aria-hidden="true">
    <div class="item" data-action="add-checknode">➕ Add Checklist</div>
  </div>

<script>
(function(){
  const overlay = document.getElementById('spotlightOverlay');
  const input = document.getElementById('spotlightInput');
  const goBtn = document.getElementById('spotlightGo');
  let isLeftCtrlDown = false;
  let lastActiveEl = null;
  let savedSelection = null;

  function openOverlay(){
    // Save focus & selection (for editors using selection restore)
    lastActiveEl = document.activeElement;
    const sel = window.getSelection && window.getSelection();
    if (sel && sel.rangeCount) savedSelection = sel.getRangeAt(0).cloneRange();

    overlay.classList.add('is-open');
    overlay.setAttribute('aria-hidden', 'false');
    setTimeout(()=>{ input.focus(); input.select(); }, 0);
  }
  function closeOverlay(restore=true){
    overlay.classList.remove('is-open');
    overlay.setAttribute('aria-hidden', 'true');
    if (restore){
      // Restore focus & selection
      if (lastActiveEl && typeof lastActiveEl.focus === 'function') {
        try { lastActiveEl.focus({preventScroll:true}); } catch(e){}
      }
      if (savedSelection) {
        const sel = window.getSelection && window.getSelection();
        if (sel) { sel.removeAllRanges(); sel.addRange(savedSelection); }
      }
    }
  }
  function searchNow(){
    const q = (input.value || '').trim();
    if (!q) { input.focus(); return; }
    const url = 'https://www.google.com/search?q=' + encodeURIComponent(q);
    window.open(url, '_blank', 'noopener');
    closeOverlay();
  }

  // Keyboard handling — detect LeftCtrl + Space to open
  document.addEventListener('keydown', (e)=>{
    if (e.code === 'ControlLeft') isLeftCtrlDown = true;
    if (e.code === 'Space' && isLeftCtrlDown && !e.shiftKey && !e.altKey && !e.metaKey) {
      e.preventDefault();
      e.stopPropagation();
      openOverlay();
    }
  }, true);
  document.addEventListener('keyup', (e)=>{
    if (e.code === 'ControlLeft') isLeftCtrlDown = false;
  }, true);

  // Overlay interactions
  overlay.addEventListener('click', (e)=>{ if (e.target === overlay) closeOverlay(); });
  document.addEventListener('keydown', (e)=>{
    if (!overlay.classList.contains('is-open')) return;
    if (e.key === 'Escape') { e.preventDefault(); closeOverlay(); }
    if (e.key === 'Enter' && document.activeElement === input) { e.preventDefault(); searchNow(); }
  });

  goBtn.addEventListener('click', (e)=>{ e.preventDefault(); searchNow(); });
})();
</script>

<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>
// ==== Canvas → PNG snapshot + utilities ====
const SNAP_MAX_W = 640, SNAP_MAX_H = 360; // thumbnail bounds

async function captureBoardSnapshot(){
  const node = document.getElementById('viewport'); // full canvas container
  const canvas = await html2canvas(node, {
    backgroundColor: null,
    useCORS: true,
    scale: 1
  });
  const full = canvas.toDataURL('image/png', 0.92);
  const thumb = await downscaleDataUrl(full, SNAP_MAX_W, SNAP_MAX_H);
  return { full, thumb };
}

async function downscaleDataUrl(dataUrl, maxW, maxH){
  const img = new Image();
  img.src = dataUrl;
  await img.decode();
  const r = Math.min(maxW / img.width, maxH / img.height, 1);
  const w = Math.max(1, Math.round(img.width * r));
  const h = Math.max(1, Math.round(img.height * r));
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const x = c.getContext('2d');
  x.drawImage(img, 0, 0, w, h);
  return c.toDataURL('image/png', 0.92);
}

/* Download helpers (used by panel buttons) */
function downloadTextAs(name, text, mime='application/json'){
  const blob = new Blob([text], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'), { href:url, download:name });
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}
function downloadDataUrl(dataUrl, filename){
  const a = Object.assign(document.createElement('a'), { href:dataUrl, download:filename });
  document.body.appendChild(a); a.click(); a.remove();
}
</script>

<div id="tbCtxMenu" role="menu" aria-hidden="true">
  <div class="title">Textbox color</div>
  <div class="row seg">
    <button type="button" data-prop="bg" class="active">Background</button>
    <button type="button" data-prop="text">Text</button>
    <button type="button" data-prop="border">Border</button>
  </div>
  <div class="row"><input id="tbColorPicker" type="color" value="#8b5cf6" /></div>
  <div class="row swatch" id="tbSwatches"></div>
</div>


<script id="tb-ctx-js">
(function(){
  const menu = document.getElementById('tbCtxMenu');
  const picker = document.getElementById('tbColorPicker');
  const swatches = document.getElementById('tbSwatches');
  const propBtns = menu ? Array.from(menu.querySelectorAll('[data-prop]')) : [];
  let currentTarget = null;
  let currentProp = 'bg';

  const QUICK = ['#ffffff','#000000','#111827','#1f2937','#6b7280','#9ca3af','#ef4444','#f59e0b','#fbbf24','#10b981','#3b82f6','#8b5cf6'];

  function ensureSwatches(){
    if(!swatches || swatches.childElementCount) return;
    QUICK.forEach(c=>{
      const b = document.createElement('button');
      b.style.background = c;
      b.title = c;
      b.addEventListener('click', ()=> applyColor(c));
      swatches.appendChild(b);
    });
  }
  function rgbToHex(rgb){
    const m = rgb && rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
    if(!m) return '#8b5cf6';
    return '#' + [m[1],m[2],m[3]].map(v=> parseInt(v,10).toString(16).padStart(2,'0')).join('');
  }
  function applyColor(hex){
    if(!currentTarget) return;
    if(currentProp==='bg'){
      currentTarget.style.background = hex;
    } else if(currentProp==='text'){
      currentTarget.style.color = hex;
    } else if(currentProp==='border'){
      currentTarget.style.borderColor = hex;
    }
  }
  function setProp(prop){
    currentProp = prop || 'bg';
    if(currentTarget){
      const cs = getComputedStyle(currentTarget);
      let seed = '#8b5cf6';
      if(currentProp==='bg' && cs.backgroundColor) seed = rgbToHex(cs.backgroundColor);
      if(currentProp==='text' && cs.color) seed = rgbToHex(cs.color);
      if(currentProp==='border' && cs.borderColor) seed = rgbToHex(cs.borderColor);
      if(picker) picker.value = seed;
    }
    propBtns.forEach(b=> b.classList.toggle('active', (b.getAttribute('data-prop')===currentProp)));
  }
  function openAt(x,y,target){
    if(!menu) return;
    ensureSwatches();
    currentTarget = target;
    menu.style.left = Math.max(8, Math.min(window.innerWidth - 240, x)) + 'px';
    menu.style.top  = Math.max(8, Math.min(window.innerHeight - 180, y)) + 'px';
    menu.style.display = 'block';
    menu.setAttribute('aria-hidden','false');
    setProp(currentProp);
  }
  function close(){
    if(!menu) return;
    menu.style.display = 'none';
    menu.setAttribute('aria-hidden','true');
    currentTarget = null;
  }

  // Expose for context menu integration
  window.openTextboxColorAt = openAt;
  window.closeTextboxColorMenu = close;

  // Bind picker and prop buttons
  if(picker) picker.addEventListener('input', (e)=> applyColor(e.target.value));
  propBtns.forEach(btn=>{
    btn.addEventListener('click', ()=> setProp(btn.getAttribute('data-prop')||'bg'));
  });

  // Prevent menu from closing itself via right-click
  // Close when clicking outside on canvas or document
  document.addEventListener('click', function(e){
    if (window.__openingTextboxColor) { return; }
    if(menu && menu.style.display==='block'){
      if(!menu.contains(e.target)){
        close();
      }
    }
  });
  if(menu) menu.addEventListener('contextmenu', (e)=> e.preventDefault());
})();
</script>

<script id="mobile-enhance-js">
(function(){
  // --- Proportional panel resize based on viewport ---
  function resizePanelsForViewport(){
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const urlPanel = document.querySelector('.url-panel');
    const savePanel = document.querySelector('.save-panel');
    // Compute a scale from 360px base width up to 420px; scale down on small screens
    const base = 420;
    const pad = 24;
    const usable = vw - pad*2;
    const width = Math.min(base, Math.max(280, Math.floor(usable * 0.92)));
    const maxH = Math.floor(vh - 140);

    [urlPanel, savePanel].forEach(el=>{
      if(!el) return;
      el.style.width = width + 'px';
      el.style.maxHeight = maxH + 'px';
      el.style.overflow = 'auto';
    });
  }
  window.addEventListener('resize', resizePanelsForViewport);
  window.addEventListener('orientationchange', resizePanelsForViewport);
  document.addEventListener('DOMContentLoaded', resizePanelsForViewport);

  // --- One-finger touch = mouse drag (synthesizer) ---
  const board = document.getElementById('viewport');
  if(board){
    // Avoid duplicating listeners
    if(!board.__oneFingerDragEnabled){
      const synth = (type, touch, target)=>{
        const ev = new MouseEvent(type, {
          bubbles: true, cancelable: true, view: window,
          clientX: touch.clientX, clientY: touch.clientY,
          screenX: touch.screenX, screenY: touch.screenY,
          buttons: type==='mouseup' ? 0 : 1
        });
        target.dispatchEvent(ev);
      };

      let touching = false, lastTarget = null;
      board.addEventListener('touchstart', (e)=>{
        if(e.touches.length !== 1) return;
        touching = true;
        const t = e.touches[0];
        lastTarget = document.elementFromPoint(t.clientX, t.clientY) || board;
        // Route to underlying target (node/textbox) to reuse existing mouse handlers
        e.preventDefault();
        synth('mousedown', t, lastTarget);
      }, {passive:false});

      board.addEventListener('touchmove', (e)=>{
        if(!touching || e.touches.length !== 1) return;
        const t = e.touches[0];
        const tgt = document.elementFromPoint(t.clientX, t.clientY) || lastTarget || board;
        e.preventDefault();
        synth('mousemove', t, tgt);
      }, {passive:false});

      board.addEventListener('touchend', (e)=>{
        if(!touching) return;
        touching = false;
        const t = (e.changedTouches && e.changedTouches[0]) || {clientX:0, clientY:0, screenX:0, screenY:0};
        const tgt = document.elementFromPoint(t.clientX, t.clientY) || lastTarget || board;
        e.preventDefault();
        synth('mouseup', t, tgt);
        lastTarget = null;
      }, {passive:false});

      board.addEventListener('touchcancel', ()=>{ touching = false; lastTarget=null; }, {passive:true});
      board.__oneFingerDragEnabled = true;
    }
  }
})();
</script>

<script id="zoom-btn-js">
(function(){
  const levels = [0.05, 0.10, 0.25, 0.50, 1.00, 1.50, 2.00, 4.00];
  const zoomPctEl = document.getElementById('zoomPct');
  const minusBtn = document.querySelector('#zoomControls [data-zoom-dir="-"]');
  const plusBtn = document.querySelector('#zoomControls [data-zoom-dir="+"]');

  function updateZoomDisplay(){
    if(zoomPctEl) zoomPctEl.textContent = Math.round(state.zoom*100) + '%';
  }

  function setZoomTo(value, anchorPx){
    const MIN = levels[0], MAX = levels[levels.length-1];
    const prev = state.zoom;
    const next = Math.min(MAX, Math.max(MIN, value));
    if(next === prev) return;
    const rectV = viewport.getBoundingClientRect();
    const cx = anchorPx ? anchorPx.x : rectV.width/2;
    const cy = anchorPx ? anchorPx.y : rectV.height/2;
    const ox = (cx - state.origin.x) / prev;
    const oy = (cy - state.origin.y) / prev;
    state.origin.x = cx - ox * next;
    state.origin.y = cy - oy * next;
    state.zoom = next;
    applyTransform();
    updateZoomDisplay();
  }

  function stepZoom(dir){
    const current = state.zoom;
    const idx = levels.findIndex(l=> Math.abs(l - current) < 0.001);
    if(idx === -1){
      // if current zoom is custom, find nearest
      let nearestIdx = 0, diff = Infinity;
      for(let i=0;i<levels.length;i++){
        const d = Math.abs(levels[i]-current);
        if(d<diff){ diff=d; nearestIdx=i; }
      }
      if(dir==='+' && nearestIdx < levels.length-1) setZoomTo(levels[nearestIdx+1]);
      else if(dir==='-' && nearestIdx > 0) setZoomTo(levels[nearestIdx-1]);
    } else {
      if(dir==='+' && idx < levels.length-1) setZoomTo(levels[idx+1]);
      else if(dir==='-' && idx > 0) setZoomTo(levels[idx-1]);
    }
  }

  if(minusBtn) minusBtn.addEventListener('click', ()=> stepZoom('-'));
  if(plusBtn) plusBtn.addEventListener('click', ()=> stepZoom('+'));

  // keep % updated when zoom changes elsewhere
  const _applyTransform = applyTransform;
  window.applyTransform = function(){
    _applyTransform();
    updateZoomDisplay();
  };
  updateZoomDisplay();
})();
</script>

<script id="zoom-steps-js">
(function(){
  const steps = [0.05, 0.10, 0.25, 0.50, 1.00, 1.50, 2.00, 4.00];
  const minus = document.getElementById('zoomMinus');
  const plus  = document.getElementById('zoomPlus');
  const label = document.getElementById('zoomLabel');
  const pctEl = document.getElementById('zoomPct');
  const viewport = document.getElementById('viewport');
  const board = document.getElementById('board');
  const bar = document.querySelector('.scale-bar');

  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function fmt(z){ return Math.round(z*100) + '%'; }

  function matrixScaleFrom(el){
    if(!el) return null;
    const t = getComputedStyle(el).transform;
    if(!t || t === 'none') return null;
    // matrix(a,b,c,d,tx,ty) -> scaleX = sqrt(a^2 + b^2)
    const m = t.match(/matrix\(([^)]+)\)/);
    if(m){
      const parts = m[1].split(',').map(v=>parseFloat(v));
      if(parts.length >= 4){
        const a = parts[0], b = parts[1];
        const scale = Math.sqrt(a*a + b*b);
        if(scale && isFinite(scale)) return scale;
      }
    }
    // matrix3d / other cases
    const m3 = t.match(/matrix3d\(([^)]+)\)/);
    if(m3){
      const p = m3[1].split(',').map(v=>parseFloat(v));
      // scaleX = length of first column (m11, m12, m13)
      if(p.length >= 16){
        const s = Math.sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2]);
        if(s && isFinite(s)) return s;
      }
    }
    return null;
  }

  function currentZoom(){
    // Prefer reading from transform of the board (source of truth)
    const m = matrixScaleFrom(board);
    if(m) return m;
    // Fallback to state.zoom
    try{ return window.state?.zoom ?? 1; } catch { return 1; }
  }

  function updateLabel(){
    const z = currentZoom();
    if(label) label.textContent = fmt(z);
    if(pctEl) pctEl.textContent = fmt(z);
  }

  function setZoom(z, anchorPx){
    // If your app uses state + applyTransform, use that path;
    // label will be corrected by our hooks below.
    if(window.state && typeof window.applyTransform === 'function'){
      const rectV = viewport.getBoundingClientRect();
      const prev = window.state.zoom ?? currentZoom();
      const next = clamp(z, steps[0], steps[steps.length-1]);

      const cx = anchorPx ? anchorPx.x : rectV.width  / 2;
      const cy = anchorPx ? anchorPx.y : rectV.height / 2;
      const ox = (cx - window.state.origin.x) / prev;
      const oy = (cy - window.state.origin.y) / prev;
      window.state.origin.x = cx - ox * next;
      window.state.origin.y = cy - oy * next;
      window.state.zoom = next;
      window.applyTransform();
    }else{
      // As a fallback, directly set transform on board
      const next = clamp(z, steps[0], steps[steps.length-1]);
      board && (board.style.transform = `scale(${next})`);
    }
    updateLabel();
  }

  function nearestIndex(z){
    let idx = 0;
    for(let i=0;i<steps.length;i++){
      if(z >= steps[i]) idx = i;
    }
    if(idx < steps.length-1){
      const a = Math.abs(z - steps[idx]);
      const b = Math.abs(z - steps[idx+1]);
      if(b < a) idx = idx+1;
    }
    return idx;
  }
  function step(dir){
    const z = currentZoom();
    const i = nearestIndex(z) + (dir>0 ? 1 : -1);
    const j = clamp(i, 0, steps.length-1);
    const rectV = viewport.getBoundingClientRect();
    setZoom(steps[j], {x: rectV.width/2, y: rectV.height/2});
  }

  if(minus) minus.addEventListener('click', ()=> step(-1));
  if(plus)  plus.addEventListener('click',  ()=> step(+1));

  // --- Keep label synced no matter what ---
  const _applyTransform = window.applyTransform;
  if(typeof _applyTransform === 'function'){
    window.applyTransform = function(){
      _applyTransform();
      updateLabel();
    };
  }

  // Observe transform style changes on #board
  if(board){
    const mo = new MutationObserver((muts)=>{
      for(const m of muts){
        if(m.type === 'attributes' && m.attributeName === 'style'){
          updateLabel();
        }
      }
    });
    mo.observe(board, { attributes: true, attributeFilter: ['style'] });
  }

  // Also refresh on common interactions (click, wheel, touch, pointer)
  const events = ['mousedown','mouseup','click','wheel','pointerdown','pointerup','touchstart','touchend'];
  events.forEach(ev=> viewport && viewport.addEventListener(ev, updateLabel, {passive:true}));

  // rAF watcher only updates when value changes (very light)
  let lastZ = null;
  function watchZoom(){
    const z = currentZoom();
    if(z !== lastZ){
      lastZ = z;
      updateLabel();
    }
    requestAnimationFrame(watchZoom);
  }

  // --- Keep controls on-screen ---
  function clampBarIntoView(){
    if(!bar) return;
    const r = bar.getBoundingClientRect();
    let x = r.left, y = r.top;
    const pad = 12;
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    // If it's out of view for any reason, snap back to bottom-left
    if(r.right < 0 || r.bottom < 0 || r.left > vw || r.top > vh){
      bar.style.left = pad + 'px';
      bar.style.bottom = pad + 'px';
      bar.style.top = 'auto';
      bar.style.right = 'auto';
    }
  }
  ['resize','orientationchange','scroll'].forEach(ev=> window.addEventListener(ev, clampBarIntoView, {passive:true}));

  document.addEventListener('DOMContentLoaded', ()=>{
    updateLabel();
    clampBarIntoView();
    watchZoom();
  });
})();
</script>
<script id="center-zoom-and-panel-toggle-js">
(function(){

  // --- Install minimalistic collapse/expand toggles on panels ---
  function makePanelCollapsible(panel){
    if(!panel || panel.classList.contains('panel-collapsible')) return;
    panel.classList.add('panel-collapsible');

    // Wrap everything after the first H3 as panel-body
    let header = panel.querySelector('h3');
    if(!header){
      // create a fallback header if missing
      header = document.createElement('h3');
      header.textContent = 'Panel';
      panel.insertBefore(header, panel.firstChild);
    }
    let body = panel.querySelector('.panel-body');
    if(!body){
      body = document.createElement('div');
      body.className = 'panel-body';
      // Move all siblings after header into body
      let sib = header.nextSibling;
      const toMove = [];
      while(sib){
        const next = sib.nextSibling;
        toMove.push(sib);
        sib = next;
      }
      toMove.forEach(n=> body.appendChild(n));
      panel.appendChild(body);
    }

    // Add a toggle button
    let btn = panel.querySelector('.panel-toggle');
    if(!btn){
      btn = document.createElement('button');
      btn.className = 'panel-toggle';
      btn.setAttribute('aria-expanded', 'true');
      btn.title = 'Collapse/Expand';
      btn.textContent = '–'; // collapse symbol
      panel.appendChild(btn);
    }

    const setCollapsed = (yes)=>{
      panel.classList.toggle('collapsed', !!yes);
      btn.setAttribute('aria-expanded', (!yes).toString());
      btn.textContent = yes ? '+' : '–';
    };

    btn.addEventListener('click', ()=> setCollapsed(!panel.classList.contains('collapsed')));
    // Optional: click header to toggle
    header.addEventListener('click', (e)=>{
      // avoid toggling when clicking buttons inside header
      if(e.target.closest('.panel-toggle')) return;
      setCollapsed(!panel.classList.contains('collapsed'));
    });
  }

  function setupPanels(){
    const urlPanel = document.querySelector('.url-panel');
    const savePanel = document.querySelector('.save-panel');
    makePanelCollapsible(urlPanel);
    makePanelCollapsible(savePanel);
  }

  document.addEventListener('DOMContentLoaded', setupPanels);
})();
</script>

<script id="panel-align-js">
(function(){
  function clamp(val, min, max){ return Math.max(min, Math.min(max, val)); }

  function layoutPanels(){
    const url = document.querySelector('.url-panel');
    const save = document.querySelector('.save-panel');
    if(!url || !save) return;

    // Ensure measured sizes are up to date
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    const pad = 12;

    // Constrain widths
    const maxW = Math.min(520, vw - pad*2);
    [url, save].forEach(el=>{
      el.style.maxWidth = maxW + 'px';
      el.style.width = Math.min(el.offsetWidth || maxW, maxW) + 'px';
      el.style.left = pad + 'px';
    });

    // Place URL panel near top-left with header buffer
    const headerBuffer = 72; // beneath the app header
    const urlTop = clamp(headerBuffer, pad, vh - pad - 100);
    url.style.top = urlTop + 'px';

    // Place Save panel directly under URL panel with gap
    const gap = 12;
    const urlRect = url.getBoundingClientRect();
    let saveTop = Math.round(urlRect.bottom + gap);
    const saveHeight = save.getBoundingClientRect().height || 200;

    // If save panel would fall off bottom, clamp and make scrollable
    if (saveTop + saveHeight + pad > vh){
      saveTop = vh - saveHeight - pad;
      // If still too tall, set max-height so it fits
      const maxH = Math.max(140, vh - saveTop - pad);
      save.style.maxHeight = maxH + 'px';
      save.style.overflow = 'auto';
    } else {
      // reset if previously constrained
      save.style.maxHeight = '';
      save.style.overflow = '';
    }
    save.style.top = clamp(saveTop, urlTop + gap, vh - pad - 100) + 'px';
  }

  window.addEventListener('resize', layoutPanels, {passive:true});
  window.addEventListener('orientationchange', layoutPanels);
  document.addEventListener('DOMContentLoaded', layoutPanels);

  // Re-run after panels collapse/expand to keep alignment
  const url = document.querySelector('.url-panel');
  const save = document.querySelector('.save-panel');
  const rerun = ()=> setTimeout(layoutPanels, 0);
  if(url) url.addEventListener('click', rerun, true);
  if(save) save.addEventListener('click', rerun, true);
})();
</script>


<script id="touch-gestures-js">
(function(){
  const viewport = document.getElementById('viewport');
  const board = document.getElementById('board');
  if(!viewport || !board) return;

  // Ensure browser doesn't hijack gestures
  viewport.style.touchAction = 'none';

  // --- Utilities ---
  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function getZoom(){
    try{ return window.state?.zoom ?? 1; }catch{ return 1; }
  }
  function setZoomAround(nextZoom, anchor){
    if(!window.applyTransform || !window.state) return;
    const rect = viewport.getBoundingClientRect();
    const prev = getZoom();
    const next = clamp(nextZoom, 0.05, 4);
    const cx = anchor ? anchor.x : rect.width/2;
    const cy = anchor ? anchor.y : rect.height/2;
    const ox = (cx - window.state.origin.x) / prev;
    const oy = (cy - window.state.origin.y) / prev;
    window.state.origin.x = cx - ox * next;
    window.state.origin.y = cy - oy * next;
    window.state.zoom = next;
    window.applyTransform();
  }
  function midpoint(a,b){
    return { x: (a.clientX+b.clientX)/2, y: (a.clientY+b.clientY)/2 };
  }
  function distance(a,b){
    const dx = a.clientX - b.clientX, dy = a.clientY - b.clientY;
    return Math.hypot(dx, dy);
  }
  function synthMouse(type, pt, opts){
    const target = document.elementFromPoint(pt.clientX, pt.clientY) || viewport;
    const ev = new MouseEvent(type, {
      bubbles: true, cancelable: true, view: window,
      clientX: pt.clientX, clientY: pt.clientY,
      screenX: pt.screenX || 0, screenY: pt.screenY || 0,
      buttons: type==='mouseup' ? 0 : (opts && opts.buttons || 1),
      button: opts && ('button' in opts) ? opts.button : 0,
      shiftKey: !!(opts && opts.shiftKey),
      ctrlKey: !!(opts && opts.ctrlKey),
      altKey: !!(opts && opts.altKey),
      metaKey: !!(opts && opts.metaKey)
    });
    target.dispatchEvent(ev);
    return target;
  }

  // --- One-finger double-tap => right-click (context menu)
  let lastTap = { t: 0, x: 0, y: 0 };
  viewport.addEventListener('touchend', (e)=>{
    if(e.changedTouches.length !== 1 || (e.touches && e.touches.length)) return;
    const t = e.changedTouches[0];
    const now = performance.now();
    const dt = now - lastTap.t;
    const dx = Math.abs(t.clientX - lastTap.x);
    const dy = Math.abs(t.clientY - lastTap.y);
    if(dt < 300 && dx < 20 && dy < 20){
      e.preventDefault();
      const target = document.elementFromPoint(t.clientX, t.clientY) || viewport;
      // Fire a native-like contextmenu
      const cm = new MouseEvent('contextmenu', {
        bubbles: true, cancelable: true, view: window,
        clientX: t.clientX, clientY: t.clientY, button: 2, buttons: 2
      });
      target.dispatchEvent(cm);
      lastTap.t = 0; // reset
    } else {
      lastTap = { t: now, x: t.clientX, y: t.clientY };
    }
  }, {passive:true});

  // --- Two-finger gestures (pinch zoom vs shift+drag) ---
  let pinchStart = null;   // { d0, z0, mid0 }
  let twoDrag = null;      // { startPt, active, tgt }
  const PINCH_THRESHOLD = 6;      // px change in distance to qualify as zoom
  const DRAG_VECTOR_THRESHOLD = 4; // px movement coherence to qualify as drag

  viewport.addEventListener('touchstart', (e)=>{
    if(e.touches.length === 2){
      e.preventDefault();
      const a = e.touches[0], b = e.touches[1];
      pinchStart = { d0: distance(a,b), z0: getZoom(), mid0: midpoint(a,b) };
      twoDrag = { startPt: midpoint(a,b), active: false, tgt: null };
    }
  }, {passive:false});

  viewport.addEventListener('touchmove', (e)=>{
    if(e.touches.length === 2 && pinchStart){
      e.preventDefault();
      const a = e.touches[0], b = e.touches[1];
      const d = distance(a,b);
      const mid = midpoint(a,b);
      const deltaD = d - pinchStart.d0;
      const vec = { x: mid.x - (twoDrag.startPt?.x||mid.x), y: mid.y - (twoDrag.startPt?.y||mid.y) };
      const vecLen = Math.hypot(vec.x, vec.y);

      // Decide gesture: pinch or two-finger drag
      if(Math.abs(deltaD) > PINCH_THRESHOLD){
        // PINCH TO ZOOM
        const scale = d / pinchStart.d0;
        const next = clamp(pinchStart.z0 * scale, 0.05, 4);
        const rect = viewport.getBoundingClientRect();
        const anchor = { x: mid.x - rect.left, y: mid.y - rect.top };
        setZoomAround(next, anchor);
      } else if(vecLen > DRAG_VECTOR_THRESHOLD){
        // TWO-FINGER DRAG => Shift + Left Drag
        const pt = { clientX: mid.x, clientY: mid.y, screenX: 0, screenY: 0 };
        if(!twoDrag.active){
          twoDrag.active = True;
        }
        if(!twoDrag.tgt){
          twoDrag.tgt = synthMouse('mousedown', pt, { shiftKey: true, buttons: 1, button: 0 });
        } else {
          synthMouse('mousemove', pt, { shiftKey: true, buttons: 1, button: 0 });
        }
      }
    }
  }, {passive:false});

  viewport.addEventListener('touchend', (e)=>{
    if(pinchStart && e.touches.length < 2){
      // End pinch/drag
      if(twoDrag && twoDrag.active && twoDrag.tgt){
        const endPt = twoDrag.startPt || {x:0,y:0};
        const pt = { clientX: endPt.x, clientY: endPt.y, screenX: 0, screenY: 0 };
        synthMouse('mouseup', pt, { shiftKey: true, buttons: 0, button: 0 });
      }
      pinchStart = null;
      twoDrag = null;
    }
  }, {passive:true});

  viewport.addEventListener('touchcancel', ()=>{ pinchStart=null; twoDrag=null; }, {passive:true});
})();
</script>





<script id="pointer-gestures-js">
(function(){
  const viewport = document.getElementById('viewport');
  const board = document.getElementById('board');
  if(!viewport || !board) return;

  // Track multiple touch pointers
  const active = new Map(); // pointerId -> {x,y}
  let pinch = null;         // {d0, z0, mid0, lastScale}
  let twoDrag = null;       // {active:boolean, last:{x,y}, tgt:EventTarget|null}
  let mode = 'none';        // 'none' | 'pinch' | 'drag'

  function clamp(v, min, max){ return Math.min(max, Math.max(min, v)); }
  function getZoom(){ try{ return window.state?.zoom ?? 1; }catch{ return 1; } }
  function setZoomAround(nextZoom, anchor){
    if(!window.applyTransform || !window.state) return;
    const rect = viewport.getBoundingClientRect();
    const prev = getZoom();
    const next = clamp(nextZoom, 0.05, 4);
    const cx = anchor ? anchor.x : rect.width/2;
    const cy = anchor ? anchor.y : rect.height/2;
    const ox = (cx - window.state.origin.x) / prev;
    const oy = (cy - window.state.origin.y) / prev;
    window.state.origin.x = cx - ox * next;
    window.state.origin.y = cy - oy * next;
    window.state.zoom = next;
    window.applyTransform();
  }
  function midpoint(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
  function distance(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }

  function synthMouse(type, pt, opts){
    const target = document.elementFromPoint(pt.x, pt.y) || viewport;
    const ev = new MouseEvent(type, {
      bubbles:true, cancelable:true, view:window,
      clientX:pt.x, clientY:pt.y,
      buttons: type==='mouseup' ? 0 : (opts && opts.buttons || 1),
      button: (opts && 'button' in opts) ? opts.button : 0,
      shiftKey: !!(opts && opts.shiftKey),
      ctrlKey: !!(opts && opts.ctrlKey),
      altKey: !!(opts && opts.altKey),
      metaKey: !!(opts && opts.metaKey),
    });
    target.dispatchEvent(ev);
    return target;
  }

  // Synthesize a wheel event at (x,y) with deltaY mapped to scale change.
  // Positive deltaY => zoom out, Negative => zoom in (typical browser convention).
  function synthWheelAt(x, y, deltaY){
    const target = document.elementFromPoint(x, y) || viewport;
    const ev = new WheelEvent('wheel', {
      bubbles: true, cancelable: true,
      clientX: x, clientY: y,
      deltaY: deltaY, deltaMode: 0, // pixel
      ctrlKey: true  // many apps treat ctrl+wheel as intentional zoom
    });
    target.dispatchEvent(ev);
    return target;
  }

  function dynamicThresholds(){
    const z = getZoom() || 1;
    const dpr = (window.devicePixelRatio || 1);
    const BASE_PINCH = 10;  // slightly permissive to favor pinch
    const BASE_DRAG  = 12;  // favor pinch over drag when ambiguous
    const zoomFactor = Math.max(0.7, 1 / Math.sqrt(z));
    const pinch = BASE_PINCH * dpr * zoomFactor;
    const drag  = BASE_DRAG  * dpr * zoomFactor;
    return { PINCH_THRESH: pinch, DRAG_THRESH: drag };
  }

  function onPointerDown(e){
    if(e.pointerType !== 'touch') return;
    try{ viewport.setPointerCapture(e.pointerId); }catch{}
    active.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(active.size === 2){
      const pts = Array.from(active.values());
      pinch = { d0: distance(pts[0], pts[1]), z0: getZoom(), mid0: midpoint(pts[0], pts[1]), lastScale: 1 };
      twoDrag = { active:false, last: pinch.mid0, tgt: null };
      mode = 'none';
      e.preventDefault();
    }
  }
  function onPointerMove(e){
    if(e.pointerType !== 'touch') return;
    if(!active.has(e.pointerId)) return;
    active.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if(active.size === 2 && pinch){
      const { PINCH_THRESH, DRAG_THRESH } = dynamicThresholds();
      const pts = Array.from(active.values());
      const mid = midpoint(pts[0], pts[1]);
      const d = distance(pts[0], pts[1]);
      const deltaD = d - pinch.d0;
      const vec = { x: mid.x - twoDrag.last.x, y: mid.y - twoDrag.last.y };
      const vecLen = Math.hypot(vec.x, vec.y);

      if(mode === 'none'){
        if(Math.abs(deltaD) > PINCH_THRESH && Math.abs(deltaD) > vecLen * 1.15){
          mode = 'pinch';
        } else if(vecLen > DRAG_THRESH){
          mode = 'drag';
        }
      }

      if(mode === 'pinch'){
        const scale = d / pinch.d0;
        const step = scale / (pinch.lastScale || 1);
        pinch.lastScale = scale;

        // Map to wheel deltaY (log-ish to keep it smooth). Negative = zoom in.
        const k = 480; // sensitivity factor
        const deltaY = -Math.sign(step-1) * Math.min(240, Math.abs(Math.log(step)) * k || 0);

        // Dispatch a wheel event at the pinch midpoint
        const rect = viewport.getBoundingClientRect();
        const px = mid.x; const py = mid.y;
        synthWheelAt(px, py, deltaY);

        // Fallback: if zoom didn't change after 2 frames, use setZoomAround
        const zBefore = getZoom();
        let checks = 0;
        function verify(){
          checks++;
          const zNow = getZoom();
          if(zNow === zBefore && checks < 2){
            requestAnimationFrame(verify);
          } else if(zNow === zBefore){
            // wheel not handled; fallback to direct zoom
            setZoomAround(pinch.z0 * scale, { x: mid.x - rect.left, y: mid.y - rect.top });
          }
        }
        requestAnimationFrame(verify);

        twoDrag.last = mid;
        e.preventDefault();
      } else if(mode === 'drag'){
        if(!twoDrag.active){
          twoDrag.active = true;
          twoDrag.tgt = synthMouse('mousedown', mid, { shiftKey:true, buttons:1, button:0 });
        } else {
          synthMouse('mousemove', mid, { shiftKey:true, buttons:1, button:0 });
        }
        twoDrag.last = mid;
        e.preventDefault();
      }
    }
  }
  function endDragIfNeeded(pt){
    if(twoDrag && twoDrag.active){
      synthMouse('mouseup', pt, { shiftKey:true, buttons:0, button:0 });
    }
  }
  function onPointerUp(e){
    if(e.pointerType !== 'touch') return;
    active.delete(e.pointerId);
    endDragIfNeeded({x:e.clientX, y:e.clientY});
    if(active.size < 2){ pinch = null; twoDrag = null; mode = 'none'; }
  }
  function onPointerCancel(e){
    active.delete(e.pointerId);
    endDragIfNeeded({x:e.clientX, y:e.clientY});
    if(active.size < 2){ pinch = null; twoDrag = null; mode = 'none'; }
  }

  // Use passive:false to ensure preventDefault is honored
  viewport.addEventListener('pointerdown', onPointerDown, {passive:false});
  viewport.addEventListener('pointermove', onPointerMove, {passive:false});
  viewport.addEventListener('pointerup', onPointerUp, {passive:false});
  viewport.addEventListener('pointercancel', onPointerCancel, {passive:false});
})();
</script>





<script id="panel-collapse-to-button-js">
(function(){
  function snapshotStyles(panel){
    if(panel.__snapshotDone) return;
    const cs = getComputedStyle(panel);
    // Save inline styles (what we can faithfully restore)
    panel.__orig = {
      width: panel.style.width || '',
      height: panel.style.height || '',
      maxHeight: panel.style.maxHeight || '',
      maxWidth: panel.style.maxWidth || '',
      overflow: panel.style.overflow || '',
      left: panel.style.left || '',
      right: panel.style.right || '',
      top: panel.style.top || '',
      bottom: panel.style.bottom || ''
    };
    // Also save computed width/height in case there were none inline set
    panel.__origComputed = {
      width: cs.width,
      height: cs.height,
      maxHeight: cs.maxHeight,
      maxWidth: cs.maxWidth
    };
    panel.__snapshotDone = true;
  }

  function restoreStyles(panel){
    if(!panel.__orig) return;
    const o = panel.__orig;
    panel.style.width = o.width;
    panel.style.height = o.height;
    panel.style.maxHeight = o.maxHeight;
    panel.style.maxWidth = o.maxWidth;
    panel.style.overflow = o.overflow;
    panel.style.left = o.left;
    panel.style.right = o.right;
    panel.style.top = o.top;
    panel.style.bottom = o.bottom;
  }

  function applyCollapsedStyles(panel){
    // Keep position, but shrink into a neat button footprint.
    panel.style.width = "44px";
    panel.style.height = "44px";
    panel.style.maxHeight = "44px";
    panel.style.maxWidth = "44px";
    panel.style.overflow = "hidden";
  }

  function makeCollapsible(panel, icon){
    if(!panel || panel.__collapsible) return;
    panel.__collapsible = true;

    // Wrap contents after header into .panel-body for easier hide/show
    let header = panel.querySelector('h3');
    if(!header){
      header = document.createElement('h3');
      header.textContent = 'Panel';
      panel.insertBefore(header, panel.firstChild);
    }
    let body = panel.querySelector('.panel-body');
    if(!body){
      body = document.createElement('div');
      body.className = 'panel-body';
      let sib = header.nextSibling;
      const move = [];
      while(sib){
        const next = sib.nextSibling;
        move.push(sib);
        sib = next;
      }
      move.forEach(n=> body.appendChild(n));
      panel.appendChild(body);
    }

    // Toggle button
    let btn = panel.querySelector('.panel-toggle');
    if(!btn){
      btn = document.createElement('button');
      btn.className = 'panel-toggle';
      btn.title = 'Collapse/Expand';
      btn.textContent = '–';
      panel.appendChild(btn);
    }

    function setCollapsed(yes){
      if(yes){
        snapshotStyles(panel);
        panel.classList.add('panel-collapsed');
        applyCollapsedStyles(panel);
      }else{
        panel.classList.remove('panel-collapsed');
        restoreStyles(panel);
      }
      btn.textContent = yes ? label : '–';
      btn.setAttribute('aria-expanded', (!yes).toString());
    }

    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      setCollapsed(!panel.classList.contains('panel-collapsed'));
    });

    // Clicking the collapsed button area should expand
    panel.addEventListener('click', (e)=>{
      if(panel.classList.contains('panel-collapsed')){
        e.stopPropagation();
        setCollapsed(false);
      }
    });

    // Initialize expanded (keeps current dimensions)
    setCollapsed(false);
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    makeCollapsible(document.querySelector('.url-panel'), '⇧');   // URL panel collapses to button
    makeCollapsible(document.querySelector('.save-panel'), '⇧');  // Save panel collapses to button
  });
})();
</script>


<script id="node-title-edit-js">
(function(){
  function focusEditable(el){
    // Make it contenteditable only during edit
    el.setAttribute('contenteditable','true');
    el.classList.add('editing');
    setTimeout(()=>{
      try{
        const sel = window.getSelection();
        const rng = document.createRange();
        rng.selectNodeContents(el);
        rng.collapse(false);
        sel.removeAllRanges(); sel.addRange(rng);
        el.focus({preventScroll:true});
      }catch(_){ el.focus(); }
    },0);

    function commit(){
      el.removeEventListener('blur', onBlur);
      el.removeEventListener('keydown', onKey);
      el.classList.remove('editing');
      // Keep contenteditable for easier mobile re-focus next time
      el.setAttribute('contenteditable','true');
    }
    function onBlur(){ commit(); }
    function onKey(e){
      if(e.key === 'Enter' || e.key === 'Escape'){
        e.preventDefault();
        commit();
      }
    }
    el.addEventListener('blur', onBlur);
    el.addEventListener('keydown', onKey);
  }

  // Tap or click title to edit
  document.addEventListener('click', function(e){
    const t = e.target.closest('.node .title');
    if(!t) return;
    focusEditable(t);
    // Do not stop propagation; we rely on global code not to preventDefault on click in titles
  }, {passive:true});

  // Prevent global gesture code from hijacking text selection in titles
  // Hint: If there are pointer handlers elsewhere, they should check e.target.closest('.title')
  // and skip preventDefault.
})();
</script>


<script id="group-menu-js">
(function(){
  const groupMenu = document.getElementById('groupMenu');
  const board = document.getElementById('board');

  window.openGroupMenu = function(x, y, group){
    if(!groupMenu || !group) return;
    const vw = window.innerWidth, vh = window.innerHeight;
    const w = 220, h = 140;
    const left = Math.max(8, Math.min(vw - w - 8, x));
    const top  = Math.max(8, Math.min(vh - h - 8, y));
    groupMenu.style.left = left + 'px';
    groupMenu.style.top  = top + 'px';
    groupMenu.classList.add('open');

    groupMenu.onclick = (e)=>{
      const act = e.target && e.target.dataset && e.target.dataset.action;
      if(!act) return;
      if(act==='rename'){
        try{
          const el = group.el || group;
          const t = el.querySelector('.title');
          if(t){
            // Immediate inline rename with caret at end
            t.classList.add('editing');
            t.setAttribute('contenteditable','true');
            setTimeout(()=>{
              try{
                const sel = window.getSelection();
                const rng = document.createRange();
                rng.selectNodeContents(t);
                rng.collapse(false);
                sel.removeAllRanges(); sel.addRange(rng);
                t.focus({preventScroll:true});
              }catch(_){ t.focus(); }
            }, 0);
            // Commit on Enter / Blur
            function commit(){
              t.classList.remove('editing');
              t.setAttribute('contenteditable','true'); // keep editable for mobile ease
              t.removeEventListener('blur', onBlur);
              t.removeEventListener('keydown', onKey);
              // sync title into model if present
              if(group && group.title !== undefined){
                group.title = t.textContent.trim();
              }
            }
            function onBlur(){ commit(); }
            function onKey(ev){
              if(ev.key==='Enter' || ev.key==='Escape'){ ev.preventDefault(); commit(); }
            }
            t.addEventListener('blur', onBlur);
            t.addEventListener('keydown', onKey);
          }
        }catch(err){ console.error('Rename group failed', err); }
      } else if(act==='duplicate'){
        try{
          const src = group;
          const srcEl = src.el || src;
          // Use canonical creation path
          const br = document.getElementById('board').getBoundingClientRect();
          const r  = srcEl.getBoundingClientRect();
          const at = { x: r.left - br.left + 24, y: r.top - br.top + 24 };
          if(typeof createGroup === 'function'){
            const g2 = createGroup(at);
            // Copy properties
            if(g2){
              g2.w = src.w || srcEl.offsetWidth;
              g2.h = src.h || srcEl.offsetHeight;
              g2.color = src.color || (getComputedStyle(srcEl).borderColor);
              g2.title = src.title || (srcEl.querySelector('.title')?.textContent || 'Group');
              // Apply to DOM
              g2.el.style.width  = g2.w + 'px';
              g2.el.style.height = g2.h + 'px';
              g2.el.style.borderColor = g2.color;
              const t2 = g2.el.querySelector('.title');
              if(t2) t2.textContent = g2.title;
            }
          }else{
            console.warn('createGroup() not available; falling back to shallow clone');
            const clone = srcEl.cloneNode(true);
            clone.classList.remove('selected');
            clone.style.left = at.x + 'px';
            clone.style.top  = at.y + 'px';
            document.getElementById('board').appendChild(clone);
          }
        }catch(err){ console.error('Duplicate group failed', err); }
      } else if(act==='delete'){
        try{
          const el = group.el || group;
          el.remove();
          // remove from state if present
          if(window.state && Array.isArray(state.groups)){
            state.groups = state.groups.filter(g=> g.id !== (group.id || el.dataset.id));
          }
        }catch(err){ console.error('Delete group failed', err); }
      }
      groupMenu.classList.remove('open');
    };
  };
})();
</script>


<script>
(function(){
  function positionMinimized(urlPanel, savePanel){
    if(!urlPanel || !savePanel) return;
    if(urlPanel.classList.contains('panel-collapsed')){
      const urlRectTop = parseInt(urlPanel.style.top || 80, 10);
      const urlRectLeft = parseInt(urlPanel.style.left || 16, 10);
      urlPanel.style.left = (isNaN(urlRectLeft)?16:urlRectLeft) + 'px';
      urlPanel.style.top  = (isNaN(urlRectTop)?80:urlRectTop) + 'px';
      if(savePanel.classList.contains('panel-collapsed')){
        const gap = 12;
        savePanel.style.left = urlPanel.style.left;
        const baseTop = parseInt(urlPanel.style.top,10) || 80;
        savePanel.style.top  = (baseTop + 56 + gap) + 'px';
      }
    }
    window.__positionMinimized = positionMinimized;
  }
  window.__positionMinimized = positionMinimized;
  window.addEventListener('resize', ()=>{
    const urlPanel=document.querySelector('.url-panel'); const savePanel=document.querySelector('.save-panel');
    positionMinimized(urlPanel, savePanel);
  });
})();
</script>

</body>
</html>
